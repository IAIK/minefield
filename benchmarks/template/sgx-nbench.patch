diff --color -ur sgx-nbench/App/App.cpp sgx-nbench1/App/App.cpp
--- sgx-nbench/App/App.cpp	2022-05-02 18:22:14.579889588 +0200
+++ sgx-nbench1/App/App.cpp	2022-05-02 16:32:45.727526000 +0200
@@ -5,7 +5,7 @@
 #include <pwd.h>
 #define MAX_PATH FILENAME_MAX
 #include "sgx_urts.h"
-#include "sgx_status.h"
+//#include "sgx_status.h"
 #include "App.h"
 #include "Enclave_u.h"
 
@@ -71,7 +71,7 @@
 
     /* Step 2: call sgx_create_enclave to initialize an enclave instance */
     /* Debug Support: set 2nd parameter to 1 */
-    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &global_eid, NULL);
+    ret = sgx_create_enclave("Enclave.signed.so", 1, &token, &updated, &global_eid, NULL);
 
 
     /* Step 3: save the launch token if it is updated */
Only in sgx-nbench/App: App.cpp~
Only in sgx-nbench/App: App.cpp.orig
Only in sgx-nbench/App: App.h~
Only in sgx-nbench/App: App.h.orig
diff --color -ur sgx-nbench/Enclave/Enclave.cpp sgx-nbench1/Enclave/Enclave.cpp
--- sgx-nbench/Enclave/Enclave.cpp	2022-05-02 18:22:14.579889588 +0200
+++ sgx-nbench1/Enclave/Enclave.cpp	2022-05-02 16:32:45.727526000 +0200
@@ -1,44 +1,55 @@
 /**
-*   Copyright(C) 2011-2015 Intel Corporation All Rights Reserved.
-*
-*   The source code, information  and  material ("Material") contained herein is
-*   owned  by Intel Corporation or its suppliers or licensors, and title to such
-*   Material remains  with Intel Corporation  or its suppliers or licensors. The
-*   Material  contains proprietary information  of  Intel or  its  suppliers and
-*   licensors. The  Material is protected by worldwide copyright laws and treaty
-*   provisions. No  part  of  the  Material  may  be  used,  copied, reproduced,
-*   modified, published, uploaded, posted, transmitted, distributed or disclosed
-*   in any way  without Intel's  prior  express written  permission. No  license
-*   under  any patent, copyright  or  other intellectual property rights  in the
-*   Material  is  granted  to  or  conferred  upon  you,  either  expressly,  by
-*   implication, inducement,  estoppel or  otherwise.  Any  license  under  such
-*   intellectual  property  rights must  be express  and  approved  by  Intel in
-*   writing.
-*
-*   *Third Party trademarks are the property of their respective owners.
-*
-*   Unless otherwise  agreed  by Intel  in writing, you may not remove  or alter
-*   this  notice or  any other notice embedded  in Materials by Intel or Intel's
-*   suppliers or licensors in any way.
-*/
+ *   Copyright(C) 2011-2015 Intel Corporation All Rights Reserved.
+ *
+ *   The source code, information  and  material ("Material") contained herein is
+ *   owned  by Intel Corporation or its suppliers or licensors, and title to such
+ *   Material remains  with Intel Corporation  or its suppliers or licensors. The
+ *   Material  contains proprietary information  of  Intel or  its  suppliers and
+ *   licensors. The  Material is protected by worldwide copyright laws and treaty
+ *   provisions. No  part  of  the  Material  may  be  used,  copied, reproduced,
+ *   modified, published, uploaded, posted, transmitted, distributed or disclosed
+ *   in any way  without Intel's  prior  express written  permission. No  license
+ *   under  any patent, copyright  or  other intellectual property rights  in the
+ *   Material  is  granted  to  or  conferred  upon  you,  either  expressly,  by
+ *   implication, inducement,  estoppel or  otherwise.  Any  license  under  such
+ *   intellectual  property  rights must  be express  and  approved  by  Intel in
+ *   writing.
+ *
+ *   *Third Party trademarks are the property of their respective owners.
+ *
+ *   Unless otherwise  agreed  by Intel  in writing, you may not remove  or alter
+ *   this  notice or  any other notice embedded  in Materials by Intel or Intel's
+ *   suppliers or licensors in any way.
+ */
 
-#include <stdarg.h>
-#include <stdio.h>      /* vsnprintf */
-#include <string.h>
-#include <math.h>
 #include "Enclave.h"
-#include "Enclave_t.h"  /* print_string */
 
-#include "nmglobal.h"
+#include "Enclave_t.h" /* print_string */
 #include "emfloat.h"
+#include "nmglobal.h"
 #include "pointer.h"
 #include "wordcat.h"
 
+#include <math.h>
+#include <stdarg.h>
+#include <stdio.h> /* vsnprintf */
+#include <string.h>
+
+extern "C" {
+uint64_t volatile __fault_count   = 0;
+uint64_t volatile __fault_pending = 0;
+uint64_t volatile __fault_mul_factor = 0;//0x2bbb871;
+}
+extern "C" void __fault_abort(void) {
+    ocall_print_string("fault detected!\n");
+    asm volatile("ud2");
+}
+
 /*
 ** TYPEDEFS
 */
-#define TRUE    1
-#define FALSE   0
+#define TRUE  1
+#define FALSE 0
 
 #ifdef LONG64
 #define MAXPOSLONG 0x7FFFFFFFFFFFFFFFL
@@ -49,30 +60,28 @@
 /************************
 ** HUFFMAN COMPRESSION **
 ************************/
-#define MAXHUFFLOOPS 500000L
+#define MAXHUFFLOOPS  500000L
 #define HUFFARRAYSIZE 5000L
-#define EXCLUDED 32000L          /* Big positive value */
-#define WORDCATSIZE 50
-
+#define EXCLUDED      32000L /* Big positive value */
+#define WORDCATSIZE   50
 
 /*
 ** TYPEDEFS
 */
 
-
 typedef struct {
-	uchar c;                /* Byte value */
-	float freq;             /* Frequency */
-	int parent;             /* Parent node */
-	int left;               /* Left pointer = 0 */
-	int right;              /* Right pointer = 1 */
+    uchar c;      /* Byte value */
+    float freq;   /* Frequency */
+    int   parent; /* Parent node */
+    int   left;   /* Left pointer = 0 */
+    int   right;  /* Right pointer = 1 */
 } huff_node;
 
 /*
 ** GLOBALS
 */
-static huff_node *hufftree;             /* The huffman tree */
-static long plaintextlen;               /* Length of plaintext */
+static huff_node *hufftree;     /* The huffman tree */
+static long       plaintextlen; /* Length of plaintext */
 
 /********************************
  * ** BACK PROPAGATION NEURAL NET **
@@ -81,66 +90,66 @@
 /*
  * ** DEFINES
  * */
-#define T 1                     /* TRUE */
-#define F 0                     /* FALSE */
-#define ERR -1
-#define MAXPATS 10              /* max number of patterns in data file */
-#define IN_X_SIZE 5             /* number of neurodes/row of input layer */
-#define IN_Y_SIZE 7             /* number of neurodes/col of input layer */
-#define IN_SIZE 35              /* equals IN_X_SIZE*IN_Y_SIZE */
-#define MID_SIZE 8              /* number of neurodes in middle layer */
-#define OUT_SIZE 8              /* number of neurodes in output layer */
-#define MARGIN 0.1              /* how near to 1,0 do we have to come to stop? */
-#define BETA 0.09               /* beta learning constant */
-#define ALPHA 0.09              /* momentum term constant */
-#define STOP 0.1                /* when worst_error less than STOP, training is done */
+#define T         1 /* TRUE */
+#define F         0 /* FALSE */
+#define ERR       -1
+#define MAXPATS   10   /* max number of patterns in data file */
+#define IN_X_SIZE 5    /* number of neurodes/row of input layer */
+#define IN_Y_SIZE 7    /* number of neurodes/col of input layer */
+#define IN_SIZE   35   /* equals IN_X_SIZE*IN_Y_SIZE */
+#define MID_SIZE  8    /* number of neurodes in middle layer */
+#define OUT_SIZE  8    /* number of neurodes in output layer */
+#define MARGIN    0.1  /* how near to 1,0 do we have to come to stop? */
+#define BETA      0.09 /* beta learning constant */
+#define ALPHA     0.09 /* momentum term constant */
+#define STOP      0.1  /* when worst_error less than STOP, training is done */
 
 /*
  * ** GLOBALS
  * */
-double  mid_wts[MID_SIZE][IN_SIZE];     /* middle layer weights */
-double  out_wts[OUT_SIZE][MID_SIZE];    /* output layer weights */
-double  mid_out[MID_SIZE];              /* middle layer output */
-double  out_out[OUT_SIZE];              /* output layer output */
-double  mid_error[MID_SIZE];            /* middle layer errors */
-double  out_error[OUT_SIZE];            /* output layer errors */
-double  mid_wt_change[MID_SIZE][IN_SIZE]; /* storage for last wt change */
-double  out_wt_change[OUT_SIZE][MID_SIZE]; /* storage for last wt change */
-double  in_pats[MAXPATS][IN_SIZE];      /* input patterns */
-double  out_pats[MAXPATS][OUT_SIZE];    /* desired output patterns */
-double  tot_out_error[MAXPATS];         /* measure of whether net is done */
-double  out_wt_cum_change[OUT_SIZE][MID_SIZE]; /* accumulated wt changes */
-double  mid_wt_cum_change[MID_SIZE][IN_SIZE];  /* accumulated wt changes */
-
-double  worst_error; /* worst error each pass through the data */
-double  average_error; /* average error each pass through the data */
-double  avg_out_error[MAXPATS]; /* average error each pattern */
-
-int iteration_count;    /* number of passes thru network so far */
-int numpats;            /* number of patterns in data file */
-int numpasses;          /* number of training passes through data file */
-int learned;            /* flag--if TRUE, network has learned all patterns */
+double mid_wts[MID_SIZE][IN_SIZE];            /* middle layer weights */
+double out_wts[OUT_SIZE][MID_SIZE];           /* output layer weights */
+double mid_out[MID_SIZE];                     /* middle layer output */
+double out_out[OUT_SIZE];                     /* output layer output */
+double mid_error[MID_SIZE];                   /* middle layer errors */
+double out_error[OUT_SIZE];                   /* output layer errors */
+double mid_wt_change[MID_SIZE][IN_SIZE];      /* storage for last wt change */
+double out_wt_change[OUT_SIZE][MID_SIZE];     /* storage for last wt change */
+double in_pats[MAXPATS][IN_SIZE];             /* input patterns */
+double out_pats[MAXPATS][OUT_SIZE];           /* desired output patterns */
+double tot_out_error[MAXPATS];                /* measure of whether net is done */
+double out_wt_cum_change[OUT_SIZE][MID_SIZE]; /* accumulated wt changes */
+double mid_wt_cum_change[MID_SIZE][IN_SIZE];  /* accumulated wt changes */
+
+double worst_error;            /* worst error each pass through the data */
+double average_error;          /* average error each pass through the data */
+double avg_out_error[MAXPATS]; /* average error each pattern */
+
+int iteration_count; /* number of passes thru network so far */
+int numpats;         /* number of patterns in data file */
+int numpasses;       /* number of training passes through data file */
+int learned;         /* flag--if TRUE, network has learned all patterns */
 
 /*
  * ** PROTOTYPES
  * */
-void DoNNET(void);
+void         DoNNET(void);
 static ulong DoNNetIteration(ulong nloops);
-static void do_mid_forward(int patt);
-static void do_out_forward();
-void display_output(int patt);
-static void do_forward_pass(int patt);
-static void do_out_error(int patt);
-static void worst_pass_error();
-static void do_mid_error();
-static void adjust_out_wts();
-static void adjust_mid_wts();
-static void do_back_pass(int patt);
-static void move_wt_changes();
-static int check_out_error();
-static void zero_changes();
-static void randomize_wts();
-static int read_data_file();
+static void  do_mid_forward(int patt);
+static void  do_out_forward();
+void         display_output(int patt);
+static void  do_forward_pass(int patt);
+static void  do_out_error(int patt);
+static void  worst_pass_error();
+static void  do_mid_error();
+static void  adjust_out_wts();
+static void  adjust_mid_wts();
+static void  do_back_pass(int patt);
+static void  move_wt_changes();
+static int   check_out_error();
+static void  zero_changes();
+static void  randomize_wts();
+static int   read_data_file();
 
 /***********************
 **  LU DECOMPOSITION  **
@@ -157,11 +166,11 @@
 /*
 ** TYPEDEFS
 */
-typedef struct
-{       union
-	{       fardouble *p;
-		fardouble (*ap)[][LUARRAYCOLS];
-	} ptrs;
+typedef struct {
+    union {
+        fardouble *p;
+        fardouble (*ap)[][LUARRAYCOLS];
+    } ptrs;
 } LUdblptr;
 
 /*
@@ -178,10 +187,10 @@
 ** TYPEDEFS
 */
 typedef struct {
-	union {
-		long *p;
-		long (*ap)[ASSIGNROWS][ASSIGNCOLS];
-	} ptrs;
+    union {
+        long *p;
+        long (*ap)[ASSIGNROWS][ASSIGNCOLS];
+    } ptrs;
 } longptr;
 
 /********************
@@ -190,16 +199,16 @@
 /*
 ** DEFINES
 */
-#define IDEAKEYSIZE 16
+#define IDEAKEYSIZE   16
 #define IDEABLOCKSIZE 8
-#define ROUNDS 8
-#define KEYLEN (6*ROUNDS+4)
+#define ROUNDS        8
+#define KEYLEN        (6 * ROUNDS + 4)
 
 /*
 ** MACROS
 */
-#define low16(x) ((x) & 0x0FFFF)
-#define MUL(x,y) (x=mul(low16(x),y))
+#define low16(x)  ((x)&0x0FFFF)
+#define MUL(x, y) (x = mul(low16(x), y))
 typedef u16 IDEAkey[KEYLEN];
 /****************************
 ** MoveMemory
@@ -207,25 +216,23 @@
 ** In most cases, this is just a memmove operation.
 ** But, not in DOS....noooo....
 */
-void MoveMemory( farvoid *destination,  /* Destination address */
-		farvoid *source,        /* Source address */
-		unsigned long nbytes)
-{
-memmove(destination, source, nbytes);
+void MoveMemory(farvoid *     destination, /* Destination address */
+                farvoid *     source,      /* Source address */
+                unsigned long nbytes) {
+    memmove(destination, source, nbytes);
 }
 
-
 /**********************************************************
  * Enclave globals					  *
  **********************************************************
  * These variables are only available in the enclave      *
  *********************************************************/
 
-void* enclave_buffer;
-void* enclave_buffer2;
-void* enclave_buffer3;
-void* enclave_buffer4;
-void* enclave_buffer5;
+void *enclave_buffer;
+void *enclave_buffer2;
+void *enclave_buffer3;
+void *enclave_buffer4;
+void *enclave_buffer5;
 
 /**********************************************************
  * Public functions					  *
@@ -233,90 +240,66 @@
  * The following functions must be placed in enclave.edl  *
  *********************************************************/
 
-void encl_AllocateMemory(size_t size){
+void encl_AllocateMemory(size_t size) {
     enclave_buffer = malloc(size);
-    if( !enclave_buffer ){
+    if ( !enclave_buffer ) {
         printf("FATAL: Enclave malloc returned NULL pointer for buffer 1\n");
-	encl_FreeMemory();
-	}
+        encl_FreeMemory();
+    }
 }
 
-void encl_AllocateMemory2(size_t size){
-   enclave_buffer2 = malloc(size);
-    if( !enclave_buffer2 ){
+void encl_AllocateMemory2(size_t size) {
+    enclave_buffer2 = malloc(size);
+    if ( !enclave_buffer2 ) {
         printf("FATAL: Enclave malloc returned NULL pointer for buffer 2\n");
-	encl_FreeMemory2();
-	}
+        encl_FreeMemory2();
+    }
 }
 
-void encl_AllocateMemory3(size_t size){
+void encl_AllocateMemory3(size_t size) {
     enclave_buffer3 = malloc(size);
-    if( !enclave_buffer3 ){
+    if ( !enclave_buffer3 ) {
         printf("FATAL: Enclave malloc returned NULL pointer for buffer 3\n");
-	encl_FreeMemory3();
-	}
+        encl_FreeMemory3();
+    }
 }
 
-void encl_AllocateMemory4(size_t size){
+void encl_AllocateMemory4(size_t size) {
     enclave_buffer4 = malloc(size);
-    if( !enclave_buffer4 ){
+    if ( !enclave_buffer4 ) {
         printf("FATAL: Enclave malloc returned NULL pointer for buffer 4\n");
-	encl_FreeMemory4();	
-	}
+        encl_FreeMemory4();
+    }
 }
 
-void encl_AllocateMemory5(size_t size){
+void encl_AllocateMemory5(size_t size) {
     enclave_buffer5 = malloc(size);
-    if( !enclave_buffer5 ){
+    if ( !enclave_buffer5 ) {
         printf("FATAL: Enclave malloc returned NULL pointer for buffer 5\n");
-	encl_FreeMemory5();
-	}
+        encl_FreeMemory5();
+    }
 }
 
-void encl_FreeMemory(){
+void encl_FreeMemory() {
     free(enclave_buffer);
 }
 
-void encl_FreeMemory2(){
+void encl_FreeMemory2() {
     free(enclave_buffer2);
 }
 
-void encl_FreeMemory3(){
+void encl_FreeMemory3() {
     free(enclave_buffer3);
 }
 
-void encl_FreeMemory4(){
+void encl_FreeMemory4() {
     free(enclave_buffer4);
 }
 
-void encl_FreeMemory5(){
+void encl_FreeMemory5() {
     free(enclave_buffer5);
 }
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
 /**********************************************************
  * Private functions					  *
  **********************************************************
@@ -330,70 +313,68 @@
 ** are moved accordingly and the length of the string at offset i
 ** is set to l.
 */
-static void stradjust(farulong *optrarray,      /* Offset pointer array */
-	faruchar *strarray,                     /* String array */
-	ulong nstrings,                         /* # of strings */
-	ulong i,                                /* Offset to adjust */
-	uchar l)                                /* New length */
-{
-unsigned long nbytes;           /* # of bytes to move */
-unsigned long j;                /* Index */
-int direction;                  /* Direction indicator */
-unsigned char adjamount;        /* Adjustment amount */
+static void stradjust(farulong *optrarray, /* Offset pointer array */
+                      faruchar *strarray,  /* String array */
+                      ulong     nstrings,  /* # of strings */
+                      ulong     i,         /* Offset to adjust */
+                      uchar     l)             /* New length */
+{
+    unsigned long nbytes;    /* # of bytes to move */
+    unsigned long j;         /* Index */
+    int           direction; /* Direction indicator */
+    unsigned char adjamount; /* Adjustment amount */
 
-/*
-** If new length is less than old length, the direction is
-** down.  If new length is greater than old length, the
-** direction is up.
-*/
-direction=(int)l - (int)*(strarray+*(optrarray+i));
-adjamount=(unsigned char)abs(direction);
+    /*
+    ** If new length is less than old length, the direction is
+    ** down.  If new length is greater than old length, the
+    ** direction is up.
+    */
+    direction = (int)l - (int)*(strarray + *(optrarray + i));
+    adjamount = (unsigned char)abs(direction);
 
-/*
-** See if the adjustment is being made to the last
-** string in the string array.  If so, we don't have to
-** do anything more than adjust the length field.
-*/
-if(i==(nstrings-1L))
-{       *(strarray+*(optrarray+i))=l;
-	return;
-}
+    /*
+    ** See if the adjustment is being made to the last
+    ** string in the string array.  If so, we don't have to
+    ** do anything more than adjust the length field.
+    */
+    if ( i == (nstrings - 1L) ) {
+        *(strarray + *(optrarray + i)) = l;
+        return;
+    }
 
-/*
-** Calculate the total # of bytes in string array from
-** location i+1 to end of array.  Whether we're moving "up" or
-** down, this is how many bytes we'll have to move.
-*/
-nbytes=*(optrarray+nstrings-1L) +
-	(unsigned long)*(strarray+*(optrarray+nstrings-1L)) + 1L -
-	*(optrarray+i+1L);
+    /*
+    ** Calculate the total # of bytes in string array from
+    ** location i+1 to end of array.  Whether we're moving "up" or
+    ** down, this is how many bytes we'll have to move.
+    */
+    nbytes = *(optrarray + nstrings - 1L) + (unsigned long)*(strarray + *(optrarray + nstrings - 1L)) + 1L -
+        *(optrarray + i + 1L);
 
-/*
-** Calculate the source and the destination.  Source is
-** string position i+1.  Destination is string position i+l
-** (i+"ell"...don't confuse 1 and l).
-** Hand this straight to memmove and let it handle the
-** "overlap" problem.
-*/
-MoveMemory((farvoid *)(strarray+*(optrarray+i)+l+1),
-	(farvoid *)(strarray+*(optrarray+i+1)),
-	(unsigned long)nbytes);
+    /*
+    ** Calculate the source and the destination.  Source is
+    ** string position i+1.  Destination is string position i+l
+    ** (i+"ell"...don't confuse 1 and l).
+    ** Hand this straight to memmove and let it handle the
+    ** "overlap" problem.
+    */
+    MoveMemory((farvoid *)(strarray + *(optrarray + i) + l + 1), (farvoid *)(strarray + *(optrarray + i + 1)),
+               (unsigned long)nbytes);
 
-/*
-** We have to adjust the offset pointer array.
-** This covers string i+1 to numstrings-1.
-*/
-for(j=i+1;j<nstrings;j++)
-	if(direction<0)
-		*(optrarray+j)=*(optrarray+j)-adjamount;
-	else
-		*(optrarray+j)=*(optrarray+j)+adjamount;
+    /*
+    ** We have to adjust the offset pointer array.
+    ** This covers string i+1 to numstrings-1.
+    */
+    for ( j = i + 1; j < nstrings; j++ )
+        if ( direction < 0 )
+            *(optrarray + j) = *(optrarray + j) - adjamount;
+        else
+            *(optrarray + j) = *(optrarray + j) + adjamount;
 
-/*
-** Store the new length and go home.
-*/
-*(strarray+*(optrarray+i))=l;
-return;
+    /*
+    ** Store the new length and go home.
+    */
+    *(strarray + *(optrarray + i)) = l;
+    return;
 }
 /****************
 ** str_is_less **
@@ -405,40 +386,38 @@
 **      4) Offsets to two strings (a & b)
 ** This function returns TRUE if string a is < string b.
 */
-static int str_is_less(farulong *optrarray, /* Offset pointers */
-	faruchar *strarray,                     /* String array */
-	ulong numstrings,                       /* # of strings */
-	ulong a, ulong b)                       /* Offsets */
+static int str_is_less(farulong *optrarray,  /* Offset pointers */
+                       faruchar *strarray,   /* String array */
+                       ulong     numstrings, /* # of strings */
+                       ulong a, ulong b)     /* Offsets */
 {
-int slen;               /* String length */
+    int slen; /* String length */
 
-/*
-** Determine which string has the minimum length.  Use that
-** to call strncmp().  If they match up to that point, the
-** string with the longer length wins.
-*/
-slen=(int)*(strarray+*(optrarray+a));
-if(slen > (int)*(strarray+*(optrarray+b)))
-	slen=(int)*(strarray+*(optrarray+b));
-
-slen=strncmp((char *)(strarray+*(optrarray+a)),
-		(char *)(strarray+*(optrarray+b)),slen);
-
-if(slen==0)
-{
-	/*
-	** They match.  Return true if the length of a
-	** is greater than the length of b.
-	*/
-	if(*(strarray+*(optrarray+a)) >
-		*(strarray+*(optrarray+b)))
-		return(TRUE);
-	return(FALSE);
-}
+    /*
+    ** Determine which string has the minimum length.  Use that
+    ** to call strncmp().  If they match up to that point, the
+    ** string with the longer length wins.
+    */
+    slen = (int)*(strarray + *(optrarray + a));
+    if ( slen > (int)*(strarray + *(optrarray + b)) )
+        slen = (int)*(strarray + *(optrarray + b));
+
+    slen = strncmp((char *)(strarray + *(optrarray + a)), (char *)(strarray + *(optrarray + b)), slen);
+
+    if ( slen == 0 ) {
+        /*
+        ** They match.  Return true if the length of a
+        ** is greater than the length of b.
+        */
+        if ( *(strarray + *(optrarray + a)) > *(strarray + *(optrarray + b)) )
+            return (TRUE);
+        return (FALSE);
+    }
 
-if(slen<0) return(TRUE);        /* a is strictly less than b */
+    if ( slen < 0 )
+        return (TRUE); /* a is strictly less than b */
 
-return(FALSE);                  /* Only other possibility */
+    return (FALSE); /* Only other possibility */
 }
 
 /************
@@ -452,89 +431,83 @@
 ** Sift the array within the bounds of those offsets (thus
 ** building a heap).
 */
-static void strsift(farulong *optrarray,        /* Offset pointers */
-	faruchar *strarray,                     /* String array */
-	ulong numstrings,                       /* # of strings */
-	ulong i, ulong j)                       /* Offsets */
-{
-unsigned long k;                /* Temporaries */
-unsigned char temp[80];
-unsigned char tlen;             /* For string lengths */
-
+static void strsift(farulong *optrarray,  /* Offset pointers */
+                    faruchar *strarray,   /* String array */
+                    ulong     numstrings, /* # of strings */
+                    ulong i, ulong j)     /* Offsets */
+{
+    unsigned long k; /* Temporaries */
+    unsigned char temp[80];
+    unsigned char tlen; /* For string lengths */
+
+    while ( (i + i) <= j ) {
+        k = i + i;
+        if ( k < j )
+            if ( str_is_less(optrarray, strarray, numstrings, k, k + 1L) )
+                ++k;
+        if ( str_is_less(optrarray, strarray, numstrings, i, k) ) {
+            /* temp=string[k] */
+            tlen = *(strarray + *(optrarray + k));
+            MoveMemory((farvoid *)&temp[0], (farvoid *)(strarray + *(optrarray + k)), (unsigned long)(tlen + 1));
+
+            /* string[k]=string[i] */
+            tlen = *(strarray + *(optrarray + i));
+            stradjust(optrarray, strarray, numstrings, k, tlen);
+            MoveMemory((farvoid *)(strarray + *(optrarray + k)), (farvoid *)(strarray + *(optrarray + i)),
+                       (unsigned long)(tlen + 1));
+
+            /* string[i]=temp */
+            tlen = temp[0];
+            stradjust(optrarray, strarray, numstrings, i, tlen);
+            MoveMemory((farvoid *)(strarray + *(optrarray + i)), (farvoid *)&temp[0], (unsigned long)(tlen + 1));
+            i = k;
+        }
+        else
+            i = j + 1;
+    }
 
-while((i+i)<=j)
-{
-	k=i+i;
-	if(k<j)
-		if(str_is_less(optrarray,strarray,numstrings,k,k+1L))
-			++k;
-	if(str_is_less(optrarray,strarray,numstrings,i,k))
-	{
-		/* temp=string[k] */
-		tlen=*(strarray+*(optrarray+k));
-		MoveMemory((farvoid *)&temp[0],
-			(farvoid *)(strarray+*(optrarray+k)),
-			(unsigned long)(tlen+1));
-
-		/* string[k]=string[i] */
-		tlen=*(strarray+*(optrarray+i));
-		stradjust(optrarray,strarray,numstrings,k,tlen);
-		MoveMemory((farvoid *)(strarray+*(optrarray+k)),
-			(farvoid *)(strarray+*(optrarray+i)),
-			(unsigned long)(tlen+1));
-
-		/* string[i]=temp */
-		tlen=temp[0];
-		stradjust(optrarray,strarray,numstrings,i,tlen);
-		MoveMemory((farvoid *)(strarray+*(optrarray+i)),
-			(farvoid *)&temp[0],
-			(unsigned long)(tlen+1));
-		i=k;
-	}
-	else
-		i=j+1;
-}
-return;
+    return;
 }
 extern "C" {
 /****************************
-*        randnum()          *
-*****************************
-** Second order linear congruential generator.
-** Constants suggested by J. G. Skellam.
-** If val==0, returns next member of sequence.
-**    val!=0, restart generator.
-*/
-int32 randnum(int32 lngval)
-{
-	register int32 interm;
-	static int32 randw[2] = { (int32)13 , (int32)117 };
+ *        randnum()          *
+ *****************************
+ ** Second order linear congruential generator.
+ ** Constants suggested by J. G. Skellam.
+ ** If val==0, returns next member of sequence.
+ **    val!=0, restart generator.
+ */
+int32 randnum(int32 lngval) {
+	
+    register int32 interm;
+    static int32   randw[2] = { (int32)13, (int32)117 };
 
-	if (lngval!=(int32)0)
-	{	randw[0]=(int32)13; randw[1]=(int32)117; }
+    if ( lngval != (int32)0 ) {
+        randw[0] = (int32)13;
+        randw[1] = (int32)117;
+    }
 
-	interm=(randw[0]*(int32)254754+randw[1]*(int32)529562)%(int32)999563;
-	randw[1]=randw[0];
-	randw[0]=interm;
-	return(interm);
+    interm   = (randw[0] * (int32)254754 + randw[1] * (int32)529562) % (int32)999563;
+    randw[1] = randw[0];
+    randw[0] = interm;
+    return (interm);
 }
 /****************************
-*         randwc()          *
-*****************************
-** Returns signed long random modulo num.
-*/
+ *         randwc()          *
+ *****************************
+ ** Returns signed long random modulo num.
+ */
 /*
 long randwc(long num)
 {
-	return(randnum(0L)%num);
+    return(randnum(0L)%num);
 }
 */
 /*
 ** Returns signed 32-bit random modulo num.
 */
-int32 randwc(int32 num)
-{
-	return(randnum((int32)0)%num);
+int32 randwc(int32 num) {
+    return (randnum((int32)0) % num);
 }
 
 /***************************
@@ -544,16 +517,15 @@
 ** positive numbers.
 */
 
-u32 abs_randwc(u32 num)
-{
-int32 temp;
+u32 abs_randwc(u32 num) {
+    int32 temp;
 
-temp=randwc(num);
-if(temp<0) temp=(int32)0-temp;
+    temp = randwc(num);
+    if ( temp < 0 )
+        temp = (int32)0 - temp;
 
-return((u32)temp);
+    return ((u32)temp);
 }
-
 }
 /************
 ** NumSift **
@@ -561,30 +533,28 @@
 ** Peforms the sift operation on a numeric array,
 ** constructing a heap in the array.
 */
-void NumSift(long *array, /* Offset into enclave_buffer */
-	unsigned long i,                /* Minimum of array */
-	unsigned long j)                /* Maximum of array */
-{
-unsigned long k;
-long temp;                              /* Used for exchange */
-
-while((i+i)<=j)
-{
-	k=i+i;
-	if(k<j)
-		if(array[k]<array[k+1L])
-			++k;
-	if(array[i]<array[k])
-	{
-		temp=array[k];
-		array[k]=array[i];
-		array[i]=temp;
-		i=k;
-	}
-	else
-		i=j+1;
-}
-return;
+void NumSift(long *        array, /* Offset into enclave_buffer */
+             unsigned long i,     /* Minimum of array */
+             unsigned long j)     /* Maximum of array */
+{
+    unsigned long k;
+    long          temp; /* Used for exchange */
+
+    while ( (i + i) <= j ) {
+        k = i + i;
+        if ( k < j )
+            if ( array[k] < array[k + 1L] )
+                ++k;
+        if ( array[i] < array[k] ) {
+            temp     = array[k];
+            array[k] = array[i];
+            array[i] = temp;
+            i        = k;
+        }
+        else
+            i = j + 1;
+    }
+    return;
 }
 /*****************************
 **     ToggleBitRun          *
@@ -592,90 +562,77 @@
 ** Set or clear a run of nbits starting at
 ** bit_addr in bitmap.
 */
-void encl_ToggleBitRun(unsigned long bit_addr, unsigned long nbits, unsigned int val)       
-{
-unsigned long bindex;   /* Index into array */
-unsigned long bitnumb;  /* Bit number */
- //printf("Calculating...Offset1: %ul Offset2: %ul\n",bit_addr,nbits);
-bit_addr = *(((unsigned long *)enclave_buffer2)+bit_addr);
-nbits = *(((unsigned long *)enclave_buffer2)+nbits);
-//printf("After...bit_addr: %ul nbits: %ul\n",bit_addr,nbits);
-
-while(nbits--)
-{
-
-	bindex=bit_addr>>6;     /* Index is number /64 */
-	bitnumb=bit_addr % 64;   /* Bit number in word */
-//printf("Iterating...%u %ul\n",val,bindex);
-	if(val)
-		((unsigned long *)enclave_buffer)[bindex]|=(1L<<bitnumb);
-	else
-		((unsigned long *)enclave_buffer)[bindex]&=~(1L<<bitnumb);
-	bit_addr++;
-}//printf("Escaped.\n");
-return;
+void encl_ToggleBitRun(unsigned long bit_addr, unsigned long nbits, unsigned int val) {
+    unsigned long bindex;  /* Index into array */
+    unsigned long bitnumb; /* Bit number */
+                           // printf("Calculating...Offset1: %ul Offset2: %ul\n",bit_addr,nbits);
+    bit_addr = *(((unsigned long *)enclave_buffer2) + bit_addr);
+    nbits    = *(((unsigned long *)enclave_buffer2) + nbits);
+    // printf("After...bit_addr: %ul nbits: %ul\n",bit_addr,nbits);
+
+    while ( nbits-- ) {
+
+        bindex  = bit_addr >> 6; /* Index is number /64 */
+        bitnumb = bit_addr % 64; /* Bit number in word */
+                                 // printf("Iterating...%u %ul\n",val,bindex);
+        if ( val )
+            ((unsigned long *)enclave_buffer)[bindex] |= (1L << bitnumb);
+        else
+            ((unsigned long *)enclave_buffer)[bindex] &= ~(1L << bitnumb);
+        bit_addr++;
+    } // printf("Escaped.\n");
+    return;
 }
 
-
-
-
 /***************
 ** FlipBitRun **
 ****************
 ** Complements a run of bits.
 */
-void encl_FlipBitRun(long bit_addr,long nbits)   
-{
-unsigned long bindex;   /* Index into array */
-unsigned long bitnumb;  /* Bit number */
+void encl_FlipBitRun(long bit_addr, long nbits) {
+    unsigned long bindex;  /* Index into array */
+    unsigned long bitnumb; /* Bit number */
 
-bit_addr = *(((unsigned long *)enclave_buffer2)+bit_addr);
-nbits = *(((unsigned long *)enclave_buffer2)+nbits);
+    bit_addr = *(((unsigned long *)enclave_buffer2) + bit_addr);
+    nbits    = *(((unsigned long *)enclave_buffer2) + nbits);
 
-while(nbits--)
-{
+    while ( nbits-- ) {
 
-	bindex=bit_addr>>6;     /* Index is number /64 */
-	bitnumb=bit_addr % 64;  /* Bit number in longword */
+        bindex  = bit_addr >> 6; /* Index is number /64 */
+        bitnumb = bit_addr % 64; /* Bit number in longword */
 
-	((unsigned long *)enclave_buffer)[bindex]^=(1L<<bitnumb);
-	bit_addr++;
-}
+        ((unsigned long *)enclave_buffer)[bindex] ^= (1L << bitnumb);
+        bit_addr++;
+    }
 
-return;
+    return;
 }
 
-unsigned long encl_bitSetup(long bitfieldarraysize, long bitoparraysize)
-{
-	long i;                         /* Index */
-	unsigned long bitoffset;                /* Offset into bitmap */
-	unsigned long nbitops=0L;
-
-	randnum((int)13);
-	//printf("Before for\n");
-	for (i=0;i<bitfieldarraysize;i++)
-	{
-		*((unsigned long *)enclave_buffer+i)=(unsigned long)0x5555555555555555;
-	}
-	//printf("After for\n");
-	randnum((int)13);
-	/* end of addition of code */
-
-	for (i=0;i<bitoparraysize;i++)
-	{
-	/* First item is offset */
-        /* *(bitoparraybase+i+i)=bitoffset=abs_randwc(262140L); */
-	*((unsigned long *)enclave_buffer2+i+i)=bitoffset=abs_randwc((int)262140);
-
-	/* Next item is run length */
-	/* *nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc(262140L-bitoffset);*/
-	nbitops+=*((unsigned long *)enclave_buffer2+i+i+1L)=abs_randwc((int)262140-bitoffset);
-	}
-
+unsigned long encl_bitSetup(long bitfieldarraysize, long bitoparraysize) {
+    long          i;         /* Index */
+    unsigned long bitoffset; /* Offset into bitmap */
+    unsigned long nbitops = 0L;
+
+    randnum((int)13);
+    // printf("Before for\n");
+    for ( i = 0; i < bitfieldarraysize; i++ ) {
+        *((unsigned long *)enclave_buffer + i) = (unsigned long)0x5555555555555555;
+    }
+    // printf("After for\n");
+    randnum((int)13);
+    /* end of addition of code */
 
-	return nbitops;
+    for ( i = 0; i < bitoparraysize; i++ ) {
+        /* First item is offset */
+        /* *(bitoparraybase+i+i)=bitoffset=abs_randwc(262140L); */
+        *((unsigned long *)enclave_buffer2 + i + i) = bitoffset = abs_randwc((int)262140);
 
+        /* Next item is run length */
+        /* *nbitops+=*(bitoparraybase+i+i+1L)=abs_randwc(262140L-bitoffset);*/
+        nbitops += *((unsigned long *)enclave_buffer2 + i + i + 1L) = abs_randwc((int)262140 - bitoffset);
+    }
 
+    return nbitops;
 }
 
 /* Fourier Private Functions */
@@ -689,28 +646,30 @@
  * ** select chooses which of the sine/cosine functions
  * **  are used.  note the special case for select=0.
  * */
-static double thefunction(double x,             /* Independent variable */
-                double omegan,          /* Omega * term */
-                        int select)             /* Choose term */
+static double thefunction(double x,      /* Independent variable */
+                          double omegan, /* Omega * term */
+                          int    select)    /* Choose term */
 {
 
     /*
      * ** Use select to pick which function we call.
      * */
-    switch(select)
-    {
-            case 0: return(pow(x+(double)1.0,x));
+    switch ( select ) {
+        case 0:
+            return (pow(x + (double)1.0, x));
 
-            case 1: return(pow(x+(double)1.0,x) * cos(omegan * x));
+        case 1:
+            return (pow(x + (double)1.0, x) * cos(omegan * x));
 
-            case 2: return(pow(x+(double)1.0,x) * sin(omegan * x));
+        case 2:
+            return (pow(x + (double)1.0, x) * sin(omegan * x));
     }
 
     /*
      * ** We should never reach this point, but the following
      * ** keeps compilers from issuing a warning message.
      * */
-    return(0.0);
+    return (0.0);
 }
 /***********************
  * ** TrapezoidIntegrate **
@@ -726,49 +685,46 @@
  * **   2 for sine terms.
  * ** Returns the value.
  * */
-static double TrapezoidIntegrate( double x0,            /* Lower bound */
-                    double x1,              /* Upper bound */
-                    int nsteps,             /* # of steps */
-                    double omegan,          /* omega * n */
-                    int select)
-{
-    double x;               /* Independent variable */
-    double dx;              /* Stepsize */
-    double rvalue;          /* Return value */
-
+static double TrapezoidIntegrate(double x0,     /* Lower bound */
+                                 double x1,     /* Upper bound */
+                                 int    nsteps, /* # of steps */
+                                 double omegan, /* omega * n */
+                                 int    select) {
+    double x;      /* Independent variable */
+    double dx;     /* Stepsize */
+    double rvalue; /* Return value */
 
     /*
      * ** Initialize independent variable
      * */
-    x=x0;
+    x = x0;
 
     /*
      * ** Calculate stepsize
      * */
-    dx=(x1 - x0) / (double)nsteps;
+    dx = (x1 - x0) / (double)nsteps;
 
     /*
      * ** Initialize the return value.
      * */
-    rvalue=thefunction(x0,omegan,select)/(double)2.0;
+    rvalue = thefunction(x0, omegan, select) / (double)2.0;
 
     /*
      * ** Compute the other terms of the integral.
      * */
-    if(nsteps!=1)
-    {       --nsteps;               /* Already done 1 step */
-            while(--nsteps )
-            {
-                x+=dx;
-                rvalue+=thefunction(x,omegan,select);
-            }
+    if ( nsteps != 1 ) {
+        --nsteps; /* Already done 1 step */
+        while ( --nsteps ) {
+            x += dx;
+            rvalue += thefunction(x, omegan, select);
+        }
     }
     /*
      * ** Finish computation
      * */
-    rvalue=(rvalue+thefunction(x1,omegan,select)/(double)2.0)*dx;
+    rvalue = (rvalue + thefunction(x1, omegan, select) / (double)2.0) * dx;
 
-    return(rvalue);
+    return (rvalue);
 }
 
 /* Neural Net Private Functions */
@@ -781,25 +737,22 @@
 ** sum of the inputs from the input pattern, with sigmoid
 ** function applied to the inputs.
 **/
-static void  do_mid_forward(int patt)
-{
-double  sum;
-int     neurode, i;
-
-for (neurode=0;neurode<MID_SIZE; neurode++)
-{
-	sum = 0.0;
-	for (i=0; i<IN_SIZE; i++)
-	{       /* compute weighted sum of input signals */
-		sum += mid_wts[neurode][i]*in_pats[patt][i];
-	}
-	/*
-	** apply sigmoid function f(x) = 1/(1+exp(-x)) to weighted sum
-	*/
-	sum = 1.0/(1.0+exp(-sum));
-	mid_out[neurode] = sum;
-}
-return;
+static void do_mid_forward(int patt) {
+    double sum;
+    int    neurode, i;
+
+    for ( neurode = 0; neurode < MID_SIZE; neurode++ ) {
+        sum = 0.0;
+        for ( i = 0; i < IN_SIZE; i++ ) { /* compute weighted sum of input signals */
+            sum += mid_wts[neurode][i] * in_pats[patt][i];
+        }
+        /*
+        ** apply sigmoid function f(x) = 1/(1+exp(-x)) to weighted sum
+        */
+        sum              = 1.0 / (1.0 + exp(-sum));
+        mid_out[neurode] = sum;
+    }
+    return;
 }
 
 /*********************
@@ -810,28 +763,25 @@
 ** the inputs (outputs from middle layer), modified by the
 ** sigmoid function.
 **/
-static void  do_out_forward()
-{
-double sum;
-int neurode, i;
-
-for (neurode=0; neurode<OUT_SIZE; neurode++)
-{
-	sum = 0.0;
-	for (i=0; i<MID_SIZE; i++)
-	{       /*
-		** compute weighted sum of input signals
-		** from middle layer
-		*/
-		sum += out_wts[neurode][i]*mid_out[i];
-	}
-	/*
-	** Apply f(x) = 1/(1+exp(-x)) to weighted input
-	*/
-	sum = 1.0/(1.0+exp(-sum));
-	out_out[neurode] = sum;
-}
-return;
+static void do_out_forward() {
+    double sum;
+    int    neurode, i;
+
+    for ( neurode = 0; neurode < OUT_SIZE; neurode++ ) {
+        sum = 0.0;
+        for ( i = 0; i < MID_SIZE; i++ ) { /*
+                                            ** compute weighted sum of input signals
+                                            ** from middle layer
+                                            */
+            sum += out_wts[neurode][i] * mid_out[i];
+        }
+        /*
+        ** Apply f(x) = 1/(1+exp(-x)) to weighted input
+        */
+        sum              = 1.0 / (1.0 + exp(-sum));
+        out_out[neurode] = sum;
+    }
+    return;
 }
 
 /*************************
@@ -851,21 +801,21 @@
 {
 int             i;
 
-	fprintf(outfile,"\n Iteration # %d",iteration_count);
-	fprintf(outfile,"\n Desired Output:  ");
+    fprintf(outfile,"\n Iteration # %d",iteration_count);
+    fprintf(outfile,"\n Desired Output:  ");
+
+    for (i=0; i<OUT_SIZE; i++)
+    {
+        fprintf(outfile,"%6.3f  ",out_pats[patt][i]);
+    }
+    fprintf(outfile,"\n Actual Output:   ");
 
-	for (i=0; i<OUT_SIZE; i++)
-	{
-		fprintf(outfile,"%6.3f  ",out_pats[patt][i]);
-	}
-	fprintf(outfile,"\n Actual Output:   ");
-
-	for (i=0; i<OUT_SIZE; i++)
-	{
-		fprintf(outfile,"%6.3f  ",out_out[i]);
-	}
-	fprintf(outfile,"\n");
-	return;
+    for (i=0; i<OUT_SIZE; i++)
+    {
+        fprintf(outfile,"%6.3f  ",out_out[i]);
+    }
+    fprintf(outfile,"\n");
+    return;
 }
 */
 
@@ -876,12 +826,11 @@
 ** NOTE: I have disabled the call to display_output() in
 **  the benchmark version -- RG.
 **/
-static void  do_forward_pass(int patt)
-{
-do_mid_forward(patt);   /* process forward pass, middle layer */
-do_out_forward();       /* process forward pass, output layer */
-/* display_output(patt);        ** display results of forward pass */
-return;
+static void do_forward_pass(int patt) {
+    do_mid_forward(patt); /* process forward pass, middle layer */
+    do_out_forward();     /* process forward pass, output layer */
+    /* display_output(patt);        ** display results of forward pass */
+    return;
 }
 
 /***********************
@@ -890,38 +839,34 @@
 ** Compute the error for the output layer neurodes.
 ** This is simply Desired - Actual.
 **/
-static void do_out_error(int patt)
-{
-int neurode;
-double error,tot_error, sum;
-
-tot_error = 0.0;
-sum = 0.0;
-for (neurode=0; neurode<OUT_SIZE; neurode++)
-{
-	out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
-	/*
-	** while we're here, also compute magnitude
-	** of total error and worst error in this pass.
-	** We use these to decide if we are done yet.
-	*/
-	error = out_error[neurode];
-	if (error <0.0)
-	{
-		sum += -error;
-		if (-error > tot_error)
-			tot_error = -error; /* worst error this pattern */
-	}
-	else
-	{
-		sum += error;
-		if (error > tot_error)
-			tot_error = error; /* worst error this pattern */
-	}
-}
-avg_out_error[patt] = sum/OUT_SIZE;
-tot_out_error[patt] = tot_error;
-return;
+static void do_out_error(int patt) {
+    int    neurode;
+    double error, tot_error, sum;
+
+    tot_error = 0.0;
+    sum       = 0.0;
+    for ( neurode = 0; neurode < OUT_SIZE; neurode++ ) {
+        out_error[neurode] = out_pats[patt][neurode] - out_out[neurode];
+        /*
+        ** while we're here, also compute magnitude
+        ** of total error and worst error in this pass.
+        ** We use these to decide if we are done yet.
+        */
+        error = out_error[neurode];
+        if ( error < 0.0 ) {
+            sum += -error;
+            if ( -error > tot_error )
+                tot_error = -error; /* worst error this pattern */
+        }
+        else {
+            sum += error;
+            if ( error > tot_error )
+                tot_error = error; /* worst error this pattern */
+        }
+    }
+    avg_out_error[patt] = sum / OUT_SIZE;
+    tot_out_error[patt] = tot_error;
+    return;
 }
 
 /***********************
@@ -929,22 +874,21 @@
 ************************
 ** Find the worst and average error in the pass and save it
 **/
-static void  worst_pass_error()
-{
-double error,sum;
+static void worst_pass_error() {
+    double error, sum;
 
-int i;
+    int i;
 
-error = 0.0;
-sum = 0.0;
-for (i=0; i<numpats; i++)
-{
-	if (tot_out_error[i] > error) error = tot_out_error[i];
-	sum += avg_out_error[i];
-}
-worst_error = error;
-average_error = sum/numpats;
-return;
+    error = 0.0;
+    sum   = 0.0;
+    for ( i = 0; i < numpats; i++ ) {
+        if ( tot_out_error[i] > error )
+            error = tot_out_error[i];
+        sum += avg_out_error[i];
+    }
+    worst_error   = error;
+    average_error = sum / numpats;
+    return;
 }
 
 /*******************
@@ -957,25 +901,23 @@
 ** Recall that f(x) is merely the output of the middle
 ** layer neurode on the forward pass.
 **/
-static void do_mid_error()
-{
-double sum;
-int neurode, i;
-
-for (neurode=0; neurode<MID_SIZE; neurode++)
-{
-	sum = 0.0;
-	for (i=0; i<OUT_SIZE; i++)
-		sum += out_wts[i][neurode]*out_error[i];
-
-	/*
-	** apply the derivative of the sigmoid here
-	** Because of the choice of sigmoid f(I), the derivative
-	** of the sigmoid is f'(I) = f(I)(1 - f(I))
-	*/
-	mid_error[neurode] = mid_out[neurode]*(1-mid_out[neurode])*sum;
-}
-return;
+static void do_mid_error() {
+    double sum;
+    int    neurode, i;
+
+    for ( neurode = 0; neurode < MID_SIZE; neurode++ ) {
+        sum = 0.0;
+        for ( i = 0; i < OUT_SIZE; i++ )
+            sum += out_wts[i][neurode] * out_error[i];
+
+        /*
+        ** apply the derivative of the sigmoid here
+        ** Because of the choice of sigmoid f(I), the derivative
+        ** of the sigmoid is f'(I) = f(I)(1 - f(I))
+        */
+        mid_error[neurode] = mid_out[neurode] * (1 - mid_out[neurode]) * sum;
+    }
+    return;
 }
 
 /*********************
@@ -986,29 +928,26 @@
 ** the middle layer.
 ** Use the Delta Rule with momentum term to adjust the weights.
 **/
-static void adjust_out_wts()
-{
-int weight, neurode;
-double learn,delta,alph;
-
-learn = BETA;
-alph  = ALPHA;
-for (neurode=0; neurode<OUT_SIZE; neurode++)
-{
-	for (weight=0; weight<MID_SIZE; weight++)
-	{
-		/* standard delta rule */
-		delta = learn * out_error[neurode] * mid_out[weight];
-
-		/* now the momentum term */
-		delta += alph * out_wt_change[neurode][weight];
-		out_wts[neurode][weight] += delta;
-
-		/* keep track of this pass's cum wt changes for next pass's momentum */
-		out_wt_cum_change[neurode][weight] += delta;
-	}
-}
-return;
+static void adjust_out_wts() {
+    int    weight, neurode;
+    double learn, delta, alph;
+
+    learn = BETA;
+    alph  = ALPHA;
+    for ( neurode = 0; neurode < OUT_SIZE; neurode++ ) {
+        for ( weight = 0; weight < MID_SIZE; weight++ ) {
+            /* standard delta rule */
+            delta = learn * out_error[neurode] * mid_out[weight];
+
+            /* now the momentum term */
+            delta += alph * out_wt_change[neurode][weight];
+            out_wts[neurode][weight] += delta;
+
+            /* keep track of this pass's cum wt changes for next pass's momentum */
+            out_wt_cum_change[neurode][weight] += delta;
+        }
+    }
+    return;
 }
 
 /*************************
@@ -1018,29 +957,26 @@
 ** errors.
 ** We use the Generalized Delta Rule with momentum term
 **/
-static void adjust_mid_wts(int patt)
-{
-int weight, neurode;
-double learn,alph,delta;
-
-learn = BETA;
-alph  = ALPHA;
-for (neurode=0; neurode<MID_SIZE; neurode++)
-{
-	for (weight=0; weight<IN_SIZE; weight++)
-	{
-		/* first the basic delta rule */
-		delta = learn * mid_error[neurode] * in_pats[patt][weight];
-
-		/* with the momentum term */
-		delta += alph * mid_wt_change[neurode][weight];
-		mid_wts[neurode][weight] += delta;
-
-		/* keep track of this pass's cum wt changes for next pass's momentum */
-		mid_wt_cum_change[neurode][weight] += delta;
-	}
-}
-return;
+static void adjust_mid_wts(int patt) {
+    int    weight, neurode;
+    double learn, alph, delta;
+
+    learn = BETA;
+    alph  = ALPHA;
+    for ( neurode = 0; neurode < MID_SIZE; neurode++ ) {
+        for ( weight = 0; weight < IN_SIZE; weight++ ) {
+            /* first the basic delta rule */
+            delta = learn * mid_error[neurode] * in_pats[patt][weight];
+
+            /* with the momentum term */
+            delta += alph * mid_wt_change[neurode][weight];
+            mid_wts[neurode][weight] += delta;
+
+            /* keep track of this pass's cum wt changes for next pass's momentum */
+            mid_wt_cum_change[neurode][weight] += delta;
+        }
+    }
+    return;
 }
 
 /*******************
@@ -1048,18 +984,16 @@
 ********************
 ** Process the backward propagation of error through network.
 **/
-void  do_back_pass(int patt)
-{
+void do_back_pass(int patt) {
 
-do_out_error(patt);
-do_mid_error();
-adjust_out_wts();
-adjust_mid_wts(patt);
+    do_out_error(patt);
+    do_mid_error();
+    adjust_out_wts();
+    adjust_mid_wts(patt);
 
-return;
+    return;
 }
 
-
 /**********************
 ** move_wt_changes() **
 ***********************
@@ -1067,28 +1001,25 @@
 ** array for use by the momentum term in this pass. Also zero out
 ** the accumulating arrays after the move.
 **/
-static void move_wt_changes()
-{
-int i,j;
+static void move_wt_changes() {
+    int i, j;
 
-for (i = 0; i<MID_SIZE; i++)
-	for (j = 0; j<IN_SIZE; j++)
-	{
-		mid_wt_change[i][j] = mid_wt_cum_change[i][j];
-		/*
-		** Zero it out for next pass accumulation.
-		*/
-		mid_wt_cum_change[i][j] = 0.0;
-	}
-
-for (i = 0; i<OUT_SIZE; i++)
-	for (j=0; j<MID_SIZE; j++)
-	{
-		out_wt_change[i][j] = out_wt_cum_change[i][j];
-		out_wt_cum_change[i][j] = 0.0;
-	}
+    for ( i = 0; i < MID_SIZE; i++ )
+        for ( j = 0; j < IN_SIZE; j++ ) {
+            mid_wt_change[i][j] = mid_wt_cum_change[i][j];
+            /*
+            ** Zero it out for next pass accumulation.
+            */
+            mid_wt_cum_change[i][j] = 0.0;
+        }
+
+    for ( i = 0; i < OUT_SIZE; i++ )
+        for ( j = 0; j < MID_SIZE; j++ ) {
+            out_wt_change[i][j]     = out_wt_cum_change[i][j];
+            out_wt_cum_change[i][j] = 0.0;
+        }
 
-return;
+    return;
 }
 
 /**********************
@@ -1100,34 +1031,34 @@
 ** is simply an arbitrary measure of how well the network
 ** has learned -- many other standards are possible.
 **/
-static int check_out_error()
-{
-int result,i,error;
+static int check_out_error() {
+    int result, i, error;
 
-result  = T;
-error   = F;
-worst_pass_error();     /* identify the worst error in this pass */
+    result = T;
+    error  = F;
+    worst_pass_error(); /* identify the worst error in this pass */
 
-/*
-#ifdef DEBUG
-printf("\n Iteration # %d",iteration_count);
-#endif
-*/
-for (i=0; i<numpats; i++)
-{
-/*      printf("\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
-	  i+1,tot_out_error[i], avg_out_error[i]);
-	fprintf(outfile,
-	 "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
-	 i+1,tot_out_error[i]);
-*/
-
-	if (worst_error >= STOP) result = F;
-	if (tot_out_error[i] >= 16.0) error = T;
-}
-
-if (error == T) result = ERR;
+    /*
+    #ifdef DEBUG
+    printf("\n Iteration # %d",iteration_count);
+    #endif
+    */
+    for ( i = 0; i < numpats; i++ ) {
+        /*      printf("\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
+              i+1,tot_out_error[i], avg_out_error[i]);
+            fprintf(outfile,
+             "\n Error pattern %d:   Worst: %8.3f; Average: %8.3f",
+             i+1,tot_out_error[i]);
+        */
+
+        if ( worst_error >= STOP )
+            result = F;
+        if ( tot_out_error[i] >= 16.0 )
+            error = T;
+    }
 
+    if ( error == T )
+        result = ERR;
 
 #ifdef DEBUG
 /* printf("\n Error this pass thru data:   Worst: %8.3f; Average: %8.3f",
@@ -1138,40 +1069,33 @@
   worst_error, average_error); */
 #endif
 
-return(result);
+    return (result);
 }
 
-
 /*******************
 ** zero_changes() **
 ********************
 ** Zero out all the wt change arrays
 **/
-static void zero_changes()
-{
-int i,j;
+static void zero_changes() {
+    int i, j;
 
-for (i = 0; i<MID_SIZE; i++)
-{
-	for (j=0; j<IN_SIZE; j++)
-	{
-		mid_wt_change[i][j] = 0.0;
-		mid_wt_cum_change[i][j] = 0.0;
-	}
-}
+    for ( i = 0; i < MID_SIZE; i++ ) {
+        for ( j = 0; j < IN_SIZE; j++ ) {
+            mid_wt_change[i][j]     = 0.0;
+            mid_wt_cum_change[i][j] = 0.0;
+        }
+    }
 
-for (i = 0; i< OUT_SIZE; i++)
-{
-	for (j=0; j<MID_SIZE; j++)
-	{
-		out_wt_change[i][j] = 0.0;
-		out_wt_cum_change[i][j] = 0.0;
-	}
-}
-return;
+    for ( i = 0; i < OUT_SIZE; i++ ) {
+        for ( j = 0; j < MID_SIZE; j++ ) {
+            out_wt_change[i][j]     = 0.0;
+            out_wt_cum_change[i][j] = 0.0;
+        }
+    }
+    return;
 }
 
-
 /********************
 ** randomize_wts() **
 *********************
@@ -1182,51 +1106,44 @@
 ** NOTE: Had to make alterations to how the random numbers were
 ** created.  -- RG.
 **/
-static void randomize_wts()
-{
-int neurode,i;
-double value;
+static void randomize_wts() {
+    int    neurode, i;
+    double value;
 
-/*
-** Following not used int benchmark version -- RG
-**
-**        printf("\n Please enter a random number seed (1..32767):  ");
-**        scanf("%d", &i);
-**        srand(i);
-*/
+    /*
+    ** Following not used int benchmark version -- RG
+    **
+    **        printf("\n Please enter a random number seed (1..32767):  ");
+    **        scanf("%d", &i);
+    **        srand(i);
+    */
 
-for (neurode = 0; neurode<MID_SIZE; neurode++)
-{
-	for(i=0; i<IN_SIZE; i++)
-	{
-	        /* value=(double)abs_randwc(100000L); */
-		value=(double)abs_randwc((int32)100000);
-		value=value/(double)100000.0 - (double) 0.5;
-		mid_wts[neurode][i] = value/2;
-	}
-}
-for (neurode=0; neurode<OUT_SIZE; neurode++)
-{
-	for(i=0; i<MID_SIZE; i++)
-	{
-	        /* value=(double)abs_randwc(100000L); */
-		value=(double)abs_randwc((int32)100000);
-		value=value/(double)10000.0 - (double) 0.5;
-		out_wts[neurode][i] = value/2;
-	}
-}
+    for ( neurode = 0; neurode < MID_SIZE; neurode++ ) {
+        for ( i = 0; i < IN_SIZE; i++ ) {
+            /* value=(double)abs_randwc(100000L); */
+            value               = (double)abs_randwc((int32)100000);
+            value               = value / (double)100000.0 - (double)0.5;
+            mid_wts[neurode][i] = value / 2;
+        }
+    }
+    for ( neurode = 0; neurode < OUT_SIZE; neurode++ ) {
+        for ( i = 0; i < MID_SIZE; i++ ) {
+            /* value=(double)abs_randwc(100000L); */
+            value               = (double)abs_randwc((int32)100000);
+            value               = value / (double)10000.0 - (double)0.5;
+            out_wts[neurode][i] = value / 2;
+        }
+    }
 
-return;
+    return;
 }
 
-
-/* 
- * printf: 
+/*
+ * printf:
  *   Invokes OCALL to display the enclave buffer to the terminal.
  */
-void printf(const char *fmt, ...)
-{
-    char buf[BUFSIZ] = {'\0'};
+void printf(const char *fmt, ...) {
+    char    buf[BUFSIZ] = { '\0' };
     va_list ap;
     va_start(ap, fmt);
     vsnprintf(buf, BUFSIZ, fmt, ap);
@@ -1234,45 +1151,47 @@
     ocall_print_string(buf);
 }
 
+extern "C" void puts(char *c) {
+    ocall_print_string(c);
+}
 
 /*************************
 ** LoadNumArrayWithRand **
 **************************
 ** Load up an array with random longs.
 */
-void encl_LoadNumArrayWithRand( /* Do not include param for pointer to arrays; we store them internally */
-		unsigned long arraysize,
-		unsigned int numarrays)         /* # of elements in array */
+void encl_LoadNumArrayWithRand(/* Do not include param for pointer to arrays; we store them internally */
+                               unsigned long arraysize, unsigned int numarrays) /* # of elements in array */
 {
-long i;                 /* Used for index */
-long *darray;        /* Destination array pointer */
-long *array = (long*)enclave_buffer; /* Use the enclave's buffer as the array pointer */
+    long  i;                              /* Used for index */
+    long *darray;                         /* Destination array pointer */
+    long *array = (long *)enclave_buffer; /* Use the enclave's buffer as the array pointer */
 
-/*
-** Initialize the random number generator
-*/
-/* randnum(13L); */
-randnum((int32)13);
+    /*
+    ** Initialize the random number generator
+    */
+    /* randnum(13L); */
+    randnum((int32)13);
 
-/*
-** Load up first array with randoms
-*/
-for(i=0L;i<arraysize;i++)
+    /*
+    ** Load up first array with randoms
+    */
+    for ( i = 0L; i < arraysize; i++ )
         /* array[i]=randnum(0L); */
-	array[i]=randnum((int32)0);
+        array[i] = randnum((int32)0);
 
-/*
-** Now, if there's more than one array to load, copy the
-** first into each of the others.
-*/
-darray=array;
-while(--numarrays)
-{       darray+=arraysize;
-	for(i=0L;i<arraysize;i++)
-		darray[i]=array[i];
-}
+    /*
+    ** Now, if there's more than one array to load, copy the
+    ** first into each of the others.
+    */
+    darray = array;
+    while ( --numarrays ) {
+        darray += arraysize;
+        for ( i = 0L; i < arraysize; i++ )
+            darray[i] = array[i];
+    }
 
-return;
+    return;
 }
 
 /****************
@@ -1282,176 +1201,171 @@
 ** integers.  Also pass in minimum and maximum offsets.
 ** This routine performs a heap sort on that array.
 */
-void encl_NumHeapSort( unsigned long base_offset,/* Again, don't pass the array pointer, but we do need an offset. */
-	unsigned long bottom,           /* Lower bound */
-	unsigned long top)              /* Upper bound */
-{
-unsigned long temp;                     /* Used to exchange elements */
-unsigned long i;                        /* Loop index */
-long *array = (long*)enclave_buffer+base_offset;
+void encl_NumHeapSort(unsigned long base_offset, /* Again, don't pass the array pointer, but we do need an offset. */
+                      unsigned long bottom,      /* Lower bound */
+                      unsigned long top)         /* Upper bound */
+{
+    unsigned long temp; /* Used to exchange elements */
+    unsigned long i;    /* Loop index */
+    long *        array = (long *)enclave_buffer + base_offset;
 
-/*
-** First, build a heap in the array
-*/
-for(i=(top/2L); i>0; --i)
-	NumSift(array,i,top);
+    /*
+    ** First, build a heap in the array
+    */
+    for ( i = (top / 2L); i > 0; --i )
+        NumSift(array, i, top);
 
-/*
-** Repeatedly extract maximum from heap and place it at the
-** end of the array.  When we get done, we'll have a sorted
-** array.
-*/
-for(i=top; i>0; --i)
-{       NumSift(array,bottom,i);
-	temp=*array;                    /* Perform exchange */
-	*array=*(array+i);
-	*(array+i)=temp;
-}
-return;
+    /*
+    ** Repeatedly extract maximum from heap and place it at the
+    ** end of the array.  When we get done, we'll have a sorted
+    ** array.
+    */
+    for ( i = top; i > 0; --i ) {
+        NumSift(array, bottom, i);
+        temp         = *array; /* Perform exchange */
+        *array       = *(array + i);
+        *(array + i) = temp;
+    }
+    return;
 }
 
-
-void test_function(const char *str){
+void test_function(const char *str) {
     printf(str);
 }
 
-int add(int x, int y){
-    return x+y;
+int add(int x, int y) {
+    return x + y;
 }
 
-void nothing(){
+void nothing() {
     return;
 }
 
-unsigned long encl_LoadStringArray(unsigned int numarrays,unsigned long arraysize)          
-{
-	unsigned long *optrarray;
-	unsigned char *strarray;
-	unsigned char *tempsbase;            
-	unsigned long *tempobase;           
-	unsigned long curroffset;       /* Current offset */
-	int fullflag;                   /* Indicates full array */
-	unsigned char stringlength;     /* Length of string */
-	unsigned char i;                /* Index */
-	unsigned long j;                /* Another index */
-	unsigned int k;                 /* Yet another index */
-	unsigned int l;                 /* Ans still one more index 			*/
-	int systemerror;                /* For holding error code */
-	unsigned long nstrings;         /* # of strings in array */
-
-	strarray= (unsigned char *)enclave_buffer;
-/*
-** Initialize random number generator.
-*/
-/* randnum(13L); */
-randnum((int32)13);
-/*
-** Start with no strings.  Initialize our current offset pointer
-** to 0.
-*/
-nstrings=0L;
-curroffset=0L;
-fullflag=0;
+unsigned long encl_LoadStringArray(unsigned int numarrays, unsigned long arraysize) {
+    unsigned long *optrarray;
+    unsigned char *strarray;
+    unsigned char *tempsbase;
+    unsigned long *tempobase;
+    unsigned long  curroffset;   /* Current offset */
+    int            fullflag;     /* Indicates full array */
+    unsigned char  stringlength; /* Length of string */
+    unsigned char  i;            /* Index */
+    unsigned long  j;            /* Another index */
+    unsigned int   k;            /* Yet another index */
+    unsigned int   l;            /* Ans still one more index 			*/
+    int            systemerror;  /* For holding error code */
+    unsigned long  nstrings;     /* # of strings in array */
 
-do
-{
-	/*
-	** Allocate a string with a random length no
-	** shorter than 4 bytes and no longer than
-	** 80 bytes.  Note we have to also make sure
-	** there's room in the array.
-	*/
+    strarray = (unsigned char *)enclave_buffer;
+    /*
+    ** Initialize random number generator.
+    */
+    /* randnum(13L); */
+    randnum((int32)13);
+    /*
+    ** Start with no strings.  Initialize our current offset pointer
+    ** to 0.
+    */
+    nstrings   = 0L;
+    curroffset = 0L;
+    fullflag   = 0;
+
+    do {
+        /*
+        ** Allocate a string with a random length no
+        ** shorter than 4 bytes and no longer than
+        ** 80 bytes.  Note we have to also make sure
+        ** there's room in the array.
+        */
         /* stringlength=(unsigned char)((1+abs_randwc(76L)) & 0xFFL);*/
-	stringlength=(unsigned char)((1+abs_randwc((int32)76)) & 0xFFL);
-	if((unsigned long)stringlength+curroffset+1L>=arraysize)
-	{       stringlength=(unsigned char)((arraysize-curroffset-1L) &
-				0xFF);
-		fullflag=1;     /* Indicates a full */
-	}
-
-	/*
-	** Store length at curroffset and advance current offset.
-	*/
-	*(strarray+curroffset)=stringlength;
-	curroffset++;
-
-	/*
-	** Fill up the rest of the string with random bytes.
-	*/
-	for(i=0;i<stringlength;i++)
-	{       *(strarray+curroffset)=
-		        /* (unsigned char)(abs_randwc((long)0xFE)); */
-			(unsigned char)(abs_randwc((int32)0xFE));
-		//printf("Hello: %c\n", *(strarray+curroffset) );
-		curroffset++;
-	}
-
-	/*
-	** Increment the # of strings counter.
-	*/
-	nstrings+=1L;
+        stringlength = (unsigned char)((1 + abs_randwc((int32)76)) & 0xFFL);
+        if ( (unsigned long)stringlength + curroffset + 1L >= arraysize ) {
+            stringlength = (unsigned char)((arraysize - curroffset - 1L) & 0xFF);
+            fullflag     = 1; /* Indicates a full */
+        }
+
+        /*
+        ** Store length at curroffset and advance current offset.
+        */
+        *(strarray + curroffset) = stringlength;
+        curroffset++;
+
+        /*
+        ** Fill up the rest of the string with random bytes.
+        */
+        for ( i = 0; i < stringlength; i++ ) {
+            *(strarray + curroffset) =
+                /* (unsigned char)(abs_randwc((long)0xFE)); */
+                (unsigned char)(abs_randwc((int32)0xFE));
+            // printf("Hello: %c\n", *(strarray+curroffset) );
+            curroffset++;
+        }
+
+        /*
+        ** Increment the # of strings counter.
+        */
+        nstrings += 1L;
 
-} while(fullflag==0);
+    } while ( fullflag == 0 );
 
-/*
-** We now have initialized a single full array.  If there
-** is more than one array, copy the original into the
-** others.
-*/
-k=1;
-tempsbase=strarray;
-while(k<numarrays)
-{       tempsbase+=arraysize+100;         /* Set base */
-	for(l=0;l<arraysize;l++)
-		tempsbase[l]=strarray[l];
-	k++;
-}
+    /*
+    ** We now have initialized a single full array.  If there
+    ** is more than one array, copy the original into the
+    ** others.
+    */
+    k         = 1;
+    tempsbase = strarray;
+    while ( k < numarrays ) {
+        tempsbase += arraysize + 100; /* Set base */
+        for ( l = 0; l < arraysize; l++ )
+            tempsbase[l] = strarray[l];
+        k++;
+    }
 
-/*
-** Now the array is full, allocate enough space for an
-** offset pointer array.
-*/
+    /*
+    ** Now the array is full, allocate enough space for an
+    ** offset pointer array.
+    */
 
-encl_AllocateMemory2(nstrings * sizeof(unsigned long) * numarrays);
+    encl_AllocateMemory2(nstrings * sizeof(unsigned long) * numarrays);
 
-optrarray=(farulong *)enclave_buffer2;
+    optrarray = (farulong *)enclave_buffer2;
 
-if(!optrarray)
-{     
+    if ( !optrarray ) {
         printf("FATAL: Enclave malloc returned NULL pointer\n");
-}
+    }
 
-/*
-** Go through the newly-built string array, building
-** offsets and putting them into the offset pointer
-** array.
-*/
-curroffset=0;
-for(j=0;j<nstrings;j++)
-{       *(optrarray+j)=curroffset;
-	curroffset+=(unsigned long)(*(strarray+curroffset))+1L;
-}
+    /*
+    ** Go through the newly-built string array, building
+    ** offsets and putting them into the offset pointer
+    ** array.
+    */
+    curroffset = 0;
+    for ( j = 0; j < nstrings; j++ ) {
+        *(optrarray + j) = curroffset;
+        curroffset += (unsigned long)(*(strarray + curroffset)) + 1L;
+    }
 
-/*
-** As above, we've made one copy of the offset pointers,
-** so duplicate this array in the remaining ones.
-*/
-k=1;
-tempobase=optrarray;
-while(k<numarrays)
-{       tempobase+=nstrings;
-	for(l=0;l<nstrings;l++)
-		tempobase[l]=optrarray[l];
-	k++;
-}
+    /*
+    ** As above, we've made one copy of the offset pointers,
+    ** so duplicate this array in the remaining ones.
+    */
+    k         = 1;
+    tempobase = optrarray;
+    while ( k < numarrays ) {
+        tempobase += nstrings;
+        for ( l = 0; l < nstrings; l++ )
+            tempobase[l] = optrarray[l];
+        k++;
+    }
 
-/*
-** All done...go home.  Pass local pointer back.
-*/
-enclave_buffer2=(void *)optrarray;
+    /*
+    ** All done...go home.  Pass local pointer back.
+    */
+    enclave_buffer2 = (void *)optrarray;
 
-//printf("%lu\n",nstrings);
-return(nstrings);
+    // printf("%lu\n",nstrings);
+    return (nstrings);
 }
 
 /****************
@@ -1465,83 +1379,68 @@
 ** an unsigned long indicating the number of strings
 ** in the array.
 */
-void encl_StrHeapSort(farulong *optrarray, faruchar *strarray, unsigned long numstrings, unsigned long bottom, unsigned long top)
-{
-unsigned char temp[80];                 /* Used to exchange elements */
-unsigned char tlen;                     /* Temp to hold length */
-unsigned long i;                        /* Loop index */
-
-//unsigned long *optrarray = oparrayOffset+(unsigned long *)enclave_buffer2;
-//unsigned char *strarray = strarrayOffset+(unsigned char *)enclave_buffer;
-
-
-
-/*
-** Build a heap in the array
-*/
-for(i=(top/2L); i>0; --i)
-	strsift(optrarray,strarray,numstrings,i,top);
-
-/*
-** Repeatedly extract maximum from heap and place it at the
-** end of the array.  When we get done, we'll have a sorted
-** array.
-*/
-for(i=top; i>0; --i)
-{
-	strsift(optrarray,strarray,numstrings,0,i);
-
-	/* temp = string[0] */
-	tlen=*strarray;
-	MoveMemory((farvoid *)&temp[0], /* Perform exchange */
-		(farvoid *)strarray,
-		(unsigned long)(tlen+1));
+void encl_StrHeapSort(farulong *optrarray, faruchar *strarray, unsigned long numstrings, unsigned long bottom,
+                      unsigned long top) {
+    unsigned char temp[80]; /* Used to exchange elements */
+    unsigned char tlen;     /* Temp to hold length */
+    unsigned long i;        /* Loop index */
 
+    // unsigned long *optrarray = oparrayOffset+(unsigned long *)enclave_buffer2;
+    // unsigned char *strarray = strarrayOffset+(unsigned char *)enclave_buffer;
 
-	/* string[0]=string[i] */
-	tlen=*(strarray+*(optrarray+i));
-	stradjust(optrarray,strarray,numstrings,0,tlen);
-	MoveMemory((farvoid *)strarray,
-		(farvoid *)(strarray+*(optrarray+i)),
-		(unsigned long)(tlen+1));
-
-	/* string[i]=temp */
-	tlen=temp[0];
-	stradjust(optrarray,strarray,numstrings,i,tlen);
-	MoveMemory((farvoid *)(strarray+*(optrarray+i)),
-		(farvoid *)&temp[0],
-		(unsigned long)(tlen+1));
-
-}
-return;
-}
+    /*
+    ** Build a heap in the array
+    */
+    for ( i = (top / 2L); i > 0; --i )
+        strsift(optrarray, strarray, numstrings, i, top);
 
+    /*
+    ** Repeatedly extract maximum from heap and place it at the
+    ** end of the array.  When we get done, we'll have a sorted
+    ** array.
+    */
+    for ( i = top; i > 0; --i ) {
+        strsift(optrarray, strarray, numstrings, 0, i);
 
-void encl_call_StrHeapSort(unsigned long nstrings, unsigned int numarrays, unsigned long arraysize)
-{
-	farulong *tempobase;            /* Temporary offset pointer base */
-	faruchar *tempsbase;            /* Temporary string base pointer */
-	//unsigned long tempobase;            /* Temporary offset pointer base */
-	//unsigned long tempsbase;            /* Temporary string base pointer */
-	tempobase=(unsigned long *)enclave_buffer2;
-	tempsbase=(unsigned char *)enclave_buffer;
-//unsigned long *optrarray = oparrayOffset+(unsigned long *)enclave_buffer2;
-//unsigned char *strarray = strarrayOffset+(unsigned char *)enclave_buffer;	
-
-
-//tempobase=optrarray;
-//tempsbase=arraybase;
-	for(int i=0;i<numarrays;i++)
-{	       
-//printf("(Before) Tempobase: %lu\n",*tempobase);	
-	//printf("(Before) Tempsbase: %d %d %d %d\n",tempsbase[0],tempsbase[1],tempsbase[2],tempsbase[3] );
-	encl_StrHeapSort(tempobase,tempsbase,nstrings,0L,nstrings-1);
-	//printf("Tempobase: %lu\n",*tempobase);	
-	//printf("Tempsbase: %d\n",*tempsbase);	
-	tempobase+=nstrings;    /* Advance base pointers */
-	tempsbase+=arraysize+100;
+        /* temp = string[0] */
+        tlen = *strarray;
+        MoveMemory((farvoid *)&temp[0], /* Perform exchange */
+                   (farvoid *)strarray, (unsigned long)(tlen + 1));
+
+        /* string[0]=string[i] */
+        tlen = *(strarray + *(optrarray + i));
+        stradjust(optrarray, strarray, numstrings, 0, tlen);
+        MoveMemory((farvoid *)strarray, (farvoid *)(strarray + *(optrarray + i)), (unsigned long)(tlen + 1));
+
+        /* string[i]=temp */
+        tlen = temp[0];
+        stradjust(optrarray, strarray, numstrings, i, tlen);
+        MoveMemory((farvoid *)(strarray + *(optrarray + i)), (farvoid *)&temp[0], (unsigned long)(tlen + 1));
+    }
+    return;
 }
 
+void encl_call_StrHeapSort(unsigned long nstrings, unsigned int numarrays, unsigned long arraysize) {
+    farulong *tempobase; /* Temporary offset pointer base */
+    faruchar *tempsbase; /* Temporary string base pointer */
+    // unsigned long tempobase;            /* Temporary offset pointer base */
+    // unsigned long tempsbase;            /* Temporary string base pointer */
+    tempobase = (unsigned long *)enclave_buffer2;
+    tempsbase = (unsigned char *)enclave_buffer;
+    // unsigned long *optrarray = oparrayOffset+(unsigned long *)enclave_buffer2;
+    // unsigned char *strarray = strarrayOffset+(unsigned char *)enclave_buffer;
+
+    // tempobase=optrarray;
+    // tempsbase=arraybase;
+    for ( int i = 0; i < numarrays; i++ ) {
+        // printf("(Before) Tempobase: %lu\n",*tempobase);
+        // printf("(Before) Tempsbase: %d %d %d %d\n",tempsbase[0],tempsbase[1],tempsbase[2],tempsbase[3] );
+        encl_StrHeapSort(tempobase, tempsbase, nstrings, 0L, nstrings - 1);
+        // printf("Tempobase: %lu\n",*tempobase);
+        // printf("Tempsbase: %d\n",*tempsbase);
+        tempobase += nstrings; /* Advance base pointers */
+        tempsbase += arraysize + 100;
+    }
 }
 
 /************************
@@ -1554,11 +1453,11 @@
 ** NOTE: The # of integration steps is fixed at
 ** 200.
 */
-void encl_DoFPUTransIteration(ulong arraysize)                /* # of coeffs */
+void encl_DoFPUTransIteration(ulong arraysize) /* # of coeffs */
 {
-    double omega;           /* Fundamental frequency */
-    unsigned long i;        /* Index */
-    unsigned long elapsed;  /* Elapsed time */
+    double        omega;   /* Fundamental frequency */
+    unsigned long i;       /* Index */
+    unsigned long elapsed; /* Elapsed time */
 
     volatile fardouble *abase = (fardouble *)enclave_buffer;
     volatile fardouble *bbase = (fardouble *)enclave_buffer2;
@@ -1568,51 +1467,41 @@
     ** calculating A[0].
     */
 
-    *abase=TrapezoidIntegrate((double)0.0,
-                        (double)2.0,
-                        200,
-                        (double)0.0,    /* No omega * n needed */
-                        0 )/(double)2.0;
+    *abase = TrapezoidIntegrate((double)0.0, (double)2.0, 200, (double)0.0, /* No omega * n needed */
+                                0) /
+        (double)2.0;
 
     /*
     ** Calculate the fundamental frequency.
     ** ( 2 * pi ) / period...and since the period
     ** is 2, omega is simply pi.
     */
-    omega=(double)3.1415926535897932;
-
-    for(i=1;i<arraysize;i++)
-    {
+    omega = (double)3.1415926535897932;
 
-            /*
-             ** Calculate A[i] terms.  Note, once again, that we
-             ** can ignore the 2/period term outside the integral
-             ** since the period is 2 and the term cancels itself
-             ** out.
-             */
-            *(abase+i)=TrapezoidIntegrate((double)0.0,
-                                (double)2.0,
-                                200,
-                                omega * (double)i,
-                                1);
-
-                /*
-                 ** Calculate the B[i] terms.
-                 */
-                *(bbase+i)=TrapezoidIntegrate((double)0.0,
-                                    (double)2.0,
-                                    200,
-                                    omega * (double)i,
-                                    2);
+    for ( i = 1; i < arraysize; i++ ) {
 
+        /*
+         ** Calculate A[i] terms.  Note, once again, that we
+         ** can ignore the 2/period term outside the integral
+         ** since the period is 2 and the term cancels itself
+         ** out.
+         */
+        *(abase + i) = TrapezoidIntegrate((double)0.0, (double)2.0, 200, omega * (double)i, 1);
+
+        /*
+         ** Calculate the B[i] terms.
+         */
+        *(bbase + i) = TrapezoidIntegrate((double)0.0, (double)2.0, 200, omega * (double)i, 2);
     }
 #ifdef DEBUG
     {
-          int i;
-          printf("\nA[i]=\n");
-          for (i=0;i<arraysize;i++) printf("%7.3g ",abase[i]);
-          printf("\nB[i]=\n(undefined) ");
-          for (i=1;i<arraysize;i++) printf("%7.3g ",bbase[i]);
+        int i;
+        printf("\nA[i]=\n");
+        for ( i = 0; i < arraysize; i++ )
+            printf("%7.3g ", abase[i]);
+        printf("\nB[i]=\n(undefined) ");
+        for ( i = 1; i < arraysize; i++ )
+            printf("%7.3g ", bbase[i]);
     }
 #endif
 }
@@ -1625,23 +1514,22 @@
 ** The array given by arraybase is loaded with positive random
 ** numbers.  Elements in the array are capped at 5,000,000.
 */
-static void LoadAssign(farlong arraybase[][ASSIGNCOLS])
-{
-	ushort i,j;
+static void LoadAssign(farlong arraybase[][ASSIGNCOLS]) {
+    ushort i, j;
 
-/*
-** Reset random number generator so things repeat.
-*/
-/* randnum(13L); */
-randnum((int32)13);
+    /*
+    ** Reset random number generator so things repeat.
+    */
+    /* randnum(13L); */
+    randnum((int32)13);
 
-for(i=0;i<ASSIGNROWS;i++)
-  for(j=0;j<ASSIGNROWS;j++){
-    /* arraybase[i][j]=abs_randwc(5000000L);*/
-    arraybase[i][j]=abs_randwc((int32)5000000);
-  }
+    for ( i = 0; i < ASSIGNROWS; i++ )
+        for ( j = 0; j < ASSIGNROWS; j++ ) {
+            /* arraybase[i][j]=abs_randwc(5000000L);*/
+            arraybase[i][j] = abs_randwc((int32)5000000);
+        }
 
-return;
+    return;
 }
 
 /*****************
@@ -1651,46 +1539,39 @@
 ** the routine that builds the initial array, and is used to copy
 ** the contents of the intial array into all following arrays.
 */
-static void CopyToAssign(farlong arrayfrom[ASSIGNROWS][ASSIGNCOLS],
-		farlong arrayto[ASSIGNROWS][ASSIGNCOLS])
-{
-ushort i,j;
+static void CopyToAssign(farlong arrayfrom[ASSIGNROWS][ASSIGNCOLS], farlong arrayto[ASSIGNROWS][ASSIGNCOLS]) {
+    ushort i, j;
 
-for(i=0;i<ASSIGNROWS;i++)
-	for(j=0;j<ASSIGNCOLS;j++)
-		arrayto[i][j]=arrayfrom[i][j];
+    for ( i = 0; i < ASSIGNROWS; i++ )
+        for ( j = 0; j < ASSIGNCOLS; j++ )
+            arrayto[i][j] = arrayfrom[i][j];
 
-return;
+    return;
 }
 
+void encl_LoadAssignArrayWithRand(unsigned long numarrays) {
+    longptr abase, abase1; /* Local for array pointer */
+    ulong   i;
 
-void encl_LoadAssignArrayWithRand(unsigned long numarrays)
-{
-	longptr abase,abase1;   /* Local for array pointer */
-	ulong i;
-
-	/*
-	** Set local array pointer
-	*/
-	abase.ptrs.p=(long *)enclave_buffer;
-	abase1.ptrs.p=(long *)enclave_buffer;
-
-	/*
-	** Set up the first array.  Then just copy it into the
-	** others.
-	*/
-	LoadAssign(*(abase.ptrs.ap));
-	if(numarrays>1)
-	for(i=1;i<numarrays;i++)
-	  {     /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
-	        /* Fixed  by Eike Dierks */
-	        abase1.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
-		CopyToAssign(*(abase.ptrs.ap),*(abase1.ptrs.ap));
-	}
-
-return;
+    /*
+    ** Set local array pointer
+    */
+    abase.ptrs.p  = (long *)enclave_buffer;
+    abase1.ptrs.p = (long *)enclave_buffer;
 
+    /*
+    ** Set up the first array.  Then just copy it into the
+    ** others.
+    */
+    LoadAssign(*(abase.ptrs.ap));
+    if ( numarrays > 1 )
+        for ( i = 1; i < numarrays; i++ ) { /* abase1.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
+            /* Fixed  by Eike Dierks */
+            abase1.ptrs.p += ASSIGNROWS * ASSIGNCOLS;
+            CopyToAssign(*(abase.ptrs.ap), *(abase1.ptrs.ap));
+        }
 
+    return;
 }
 
 /***********************
@@ -1700,50 +1581,47 @@
 ** row and column basis.  These minima are subtracted from
 ** their rows and columns, creating a new tableau.
 */
-static void calc_minimum_costs(long tableau[][ASSIGNCOLS])
-{
-ushort i,j;              /* Index variables */
-long currentmin;        /* Current minimum */
-/*
-** Determine minimum costs on row basis.  This is done by
-** subtracting -- on a row-per-row basis -- the minum value
-** for that row.
-*/
-for(i=0;i<ASSIGNROWS;i++)
-{
-	currentmin=MAXPOSLONG;  /* Initialize minimum */
-	for(j=0;j<ASSIGNCOLS;j++)
-		if(tableau[i][j]<currentmin)
-			currentmin=tableau[i][j];
+static void calc_minimum_costs(long tableau[][ASSIGNCOLS]) {
+    ushort i, j;       /* Index variables */
+    long   currentmin; /* Current minimum */
+    /*
+    ** Determine minimum costs on row basis.  This is done by
+    ** subtracting -- on a row-per-row basis -- the minum value
+    ** for that row.
+    */
+    for ( i = 0; i < ASSIGNROWS; i++ ) {
+        currentmin = MAXPOSLONG; /* Initialize minimum */
+        for ( j = 0; j < ASSIGNCOLS; j++ )
+            if ( tableau[i][j] < currentmin )
+                currentmin = tableau[i][j];
 
-	for(j=0;j<ASSIGNCOLS;j++)
-		tableau[i][j]-=currentmin;
-}
+        for ( j = 0; j < ASSIGNCOLS; j++ )
+            tableau[i][j] -= currentmin;
+    }
 
-/*
-** Determine minimum cost on a column basis.  This works
-** just as above, only now we step through the array
-** column-wise
-*/
-for(j=0;j<ASSIGNCOLS;j++)
-{
-	currentmin=MAXPOSLONG;  /* Initialize minimum */
-	for(i=0;i<ASSIGNROWS;i++)
-		if(tableau[i][j]<currentmin)
-			currentmin=tableau[i][j];
-
-	/*
-	** Here, we'll take the trouble to see if the current
-	** minimum is zero.  This is likely worth it, since the
-	** preceding loop will have created at least one zero in
-	** each row.  We can save ourselves a few iterations.
-	*/
-	if(currentmin!=0)
-		for(i=0;i<ASSIGNROWS;i++)
-			tableau[i][j]-=currentmin;
-}
+    /*
+    ** Determine minimum cost on a column basis.  This works
+    ** just as above, only now we step through the array
+    ** column-wise
+    */
+    for ( j = 0; j < ASSIGNCOLS; j++ ) {
+        currentmin = MAXPOSLONG; /* Initialize minimum */
+        for ( i = 0; i < ASSIGNROWS; i++ )
+            if ( tableau[i][j] < currentmin )
+                currentmin = tableau[i][j];
+
+        /*
+        ** Here, we'll take the trouble to see if the current
+        ** minimum is zero.  This is likely worth it, since the
+        ** preceding loop will have created at least one zero in
+        ** each row.  We can save ourselves a few iterations.
+        */
+        if ( currentmin != 0 )
+            for ( i = 0; i < ASSIGNROWS; i++ )
+                tableau[i][j] -= currentmin;
+    }
 
-return;
+    return;
 }
 
 /**********************
@@ -1759,111 +1637,105 @@
 ** Returns the number of selections made.  If this equals
 ** the number of rows, then an optimum has been determined.
 */
-static int first_assignments(long tableau[][ASSIGNCOLS],
-		short assignedtableau[][ASSIGNCOLS])
-{
-ushort i,j,k;                   /* Index variables */
-ushort numassigns;              /* # of assignments */
-ushort totnumassigns;           /* Total # of assignments */
-ushort numzeros;                /* # of zeros in row */
-int selected=0;                 /* Flag used to indicate selection */
+static int first_assignments(long tableau[][ASSIGNCOLS], short assignedtableau[][ASSIGNCOLS]) {
+    ushort i, j, k;       /* Index variables */
+    ushort numassigns;    /* # of assignments */
+    ushort totnumassigns; /* Total # of assignments */
+    ushort numzeros;      /* # of zeros in row */
+    int    selected = 0;  /* Flag used to indicate selection */
 
-/*
-** Clear the assignedtableau, setting all members to show that
-** no one is yet assigned, eliminated, or anything.
-*/
-for(i=0;i<ASSIGNROWS;i++)
-	for(j=0;j<ASSIGNCOLS;j++)
-		assignedtableau[i][j]=0;
-
-totnumassigns=0;
-do {
-	numassigns=0;
-	/*
-	** Step through rows.  For each one that is not currently
-	** assigned, see if the row has only one zero in it.  If so,
-	** mark that as an assigned row/col.  Eliminate other zeros
-	** in the same column.
-	*/
-	for(i=0;i<ASSIGNROWS;i++)
-	{       numzeros=0;
-		for(j=0;j<ASSIGNCOLS;j++)
-			if(tableau[i][j]==0L)
-				if(assignedtableau[i][j]==0)
-				{       numzeros++;
-					selected=j;
-				}
-		if(numzeros==1)
-		{       numassigns++;
-			totnumassigns++;
-			assignedtableau[i][selected]=1;
-			for(k=0;k<ASSIGNROWS;k++)
-				if((k!=i) &&
-				   (tableau[k][selected]==0))
-					assignedtableau[k][selected]=2;
-		}
-	}
-	/*
-	** Step through columns, doing same as above.  Now, be careful
-	** of items in the other rows of a selected column.
-	*/
-	for(j=0;j<ASSIGNCOLS;j++)
-	{       numzeros=0;
-		for(i=0;i<ASSIGNROWS;i++)
-			if(tableau[i][j]==0L)
-				if(assignedtableau[i][j]==0)
-				{       numzeros++;
-					selected=i;
-				}
-		if(numzeros==1)
-		{       numassigns++;
-			totnumassigns++;
-			assignedtableau[selected][j]=1;
-			for(k=0;k<ASSIGNCOLS;k++)
-				if((k!=j) &&
-				   (tableau[selected][k]==0))
-					assignedtableau[selected][k]=2;
-		}
-	}
-	/*
-	** Repeat until no more assignments to be made.
-	*/
-} while(numassigns!=0);
+    /*
+    ** Clear the assignedtableau, setting all members to show that
+    ** no one is yet assigned, eliminated, or anything.
+    */
+    for ( i = 0; i < ASSIGNROWS; i++ )
+        for ( j = 0; j < ASSIGNCOLS; j++ )
+            assignedtableau[i][j] = 0;
+
+    totnumassigns = 0;
+    do {
+        numassigns = 0;
+        /*
+        ** Step through rows.  For each one that is not currently
+        ** assigned, see if the row has only one zero in it.  If so,
+        ** mark that as an assigned row/col.  Eliminate other zeros
+        ** in the same column.
+        */
+        for ( i = 0; i < ASSIGNROWS; i++ ) {
+            numzeros = 0;
+            for ( j = 0; j < ASSIGNCOLS; j++ )
+                if ( tableau[i][j] == 0L )
+                    if ( assignedtableau[i][j] == 0 ) {
+                        numzeros++;
+                        selected = j;
+                    }
+            if ( numzeros == 1 ) {
+                numassigns++;
+                totnumassigns++;
+                assignedtableau[i][selected] = 1;
+                for ( k = 0; k < ASSIGNROWS; k++ )
+                    if ( (k != i) && (tableau[k][selected] == 0) )
+                        assignedtableau[k][selected] = 2;
+            }
+        }
+        /*
+        ** Step through columns, doing same as above.  Now, be careful
+        ** of items in the other rows of a selected column.
+        */
+        for ( j = 0; j < ASSIGNCOLS; j++ ) {
+            numzeros = 0;
+            for ( i = 0; i < ASSIGNROWS; i++ )
+                if ( tableau[i][j] == 0L )
+                    if ( assignedtableau[i][j] == 0 ) {
+                        numzeros++;
+                        selected = i;
+                    }
+            if ( numzeros == 1 ) {
+                numassigns++;
+                totnumassigns++;
+                assignedtableau[selected][j] = 1;
+                for ( k = 0; k < ASSIGNCOLS; k++ )
+                    if ( (k != j) && (tableau[selected][k] == 0) )
+                        assignedtableau[selected][k] = 2;
+            }
+        }
+        /*
+        ** Repeat until no more assignments to be made.
+        */
+    } while ( numassigns != 0 );
 
-/*
-** See if we can leave at this point.
-*/
-if(totnumassigns==ASSIGNROWS) return(totnumassigns);
+    /*
+    ** See if we can leave at this point.
+    */
+    if ( totnumassigns == ASSIGNROWS )
+        return (totnumassigns);
 
-/*
-** Now step through the array by row.  If you find any unassigned
-** zeros, pick the first in the row.  Eliminate all zeros from
-** that same row & column.  This occurs if there are multiple optima...
-** possibly.
-*/
-for(i=0;i<ASSIGNROWS;i++)
-{       selected=-1;
-	for(j=0;j<ASSIGNCOLS;j++)
-		if((tableau[i][j]==0L) &&
-		   (assignedtableau[i][j]==0))
-		{       selected=j;
-			break;
-		}
-	if(selected!=-1)
-	{       assignedtableau[i][selected]=1;
-		totnumassigns++;
-		for(k=0;k<ASSIGNCOLS;k++)
-			if((k!=selected) &&
-			   (tableau[i][k]==0L))
-				assignedtableau[i][k]=2;
-		for(k=0;k<ASSIGNROWS;k++)
-			if((k!=i) &&
-			   (tableau[k][selected]==0L))
-				assignedtableau[k][selected]=2;
-	}
-}
+    /*
+    ** Now step through the array by row.  If you find any unassigned
+    ** zeros, pick the first in the row.  Eliminate all zeros from
+    ** that same row & column.  This occurs if there are multiple optima...
+    ** possibly.
+    */
+    for ( i = 0; i < ASSIGNROWS; i++ ) {
+        selected = -1;
+        for ( j = 0; j < ASSIGNCOLS; j++ )
+            if ( (tableau[i][j] == 0L) && (assignedtableau[i][j] == 0) ) {
+                selected = j;
+                break;
+            }
+        if ( selected != -1 ) {
+            assignedtableau[i][selected] = 1;
+            totnumassigns++;
+            for ( k = 0; k < ASSIGNCOLS; k++ )
+                if ( (k != selected) && (tableau[i][k] == 0L) )
+                    assignedtableau[i][k] = 2;
+            for ( k = 0; k < ASSIGNROWS; k++ )
+                if ( (k != i) && (tableau[k][selected] == 0L) )
+                    assignedtableau[k][selected] = 2;
+        }
+    }
 
-return(totnumassigns);
+    return (totnumassigns);
 }
 
 /***********************
@@ -1874,148 +1746,137 @@
 ** refer to the algorithm's source, mentioned in comments
 ** toward the beginning of the program.
 */
-static void second_assignments(long tableau[][ASSIGNCOLS],
-		short assignedtableau[][ASSIGNCOLS])
-{
-int i,j;                                /* Indexes */
-short linesrow[ASSIGNROWS];
-short linescol[ASSIGNCOLS];
-long smallest;                          /* Holds smallest value */
-ushort numassigns;                      /* Number of assignments */
-ushort newrows;                         /* New rows to be considered */
-/*
-** Clear the linesrow and linescol arrays.
-*/
-for(i=0;i<ASSIGNROWS;i++)
-	linesrow[i]=0;
-for(i=0;i<ASSIGNCOLS;i++)
-	linescol[i]=0;
+static void second_assignments(long tableau[][ASSIGNCOLS], short assignedtableau[][ASSIGNCOLS]) {
+    int    i, j; /* Indexes */
+    short  linesrow[ASSIGNROWS];
+    short  linescol[ASSIGNCOLS];
+    long   smallest;   /* Holds smallest value */
+    ushort numassigns; /* Number of assignments */
+    ushort newrows;    /* New rows to be considered */
+    /*
+    ** Clear the linesrow and linescol arrays.
+    */
+    for ( i = 0; i < ASSIGNROWS; i++ )
+        linesrow[i] = 0;
+    for ( i = 0; i < ASSIGNCOLS; i++ )
+        linescol[i] = 0;
 
-/*
-** Scan rows, flag each row that has no assignment in it.
-*/
-for(i=0;i<ASSIGNROWS;i++)
-{       numassigns=0;
-	for(j=0;j<ASSIGNCOLS;j++)
-		if(assignedtableau[i][j]==1)
-		{       numassigns++;
-			break;
-		}
-	if(numassigns==0) linesrow[i]=1;
-}
-
-do {
-
-	newrows=0;
-	/*
-	** For each row checked above, scan for any zeros.  If found,
-	** check the associated column.
-	*/
-	for(i=0;i<ASSIGNROWS;i++)
-	{       if(linesrow[i]==1)
-			for(j=0;j<ASSIGNCOLS;j++)
-				if(tableau[i][j]==0)
-					linescol[j]=1;
-	}
-
-	/*
-	** Now scan checked columns.  If any contain assigned zeros, check
-	** the associated row.
-	*/
-	for(j=0;j<ASSIGNCOLS;j++)
-		if(linescol[j]==1)
-			for(i=0;i<ASSIGNROWS;i++)
-				if((assignedtableau[i][j]==1) &&
-					(linesrow[i]!=1))
-				{
-					linesrow[i]=1;
-					newrows++;
-				}
-} while(newrows!=0);
+    /*
+    ** Scan rows, flag each row that has no assignment in it.
+    */
+    for ( i = 0; i < ASSIGNROWS; i++ ) {
+        numassigns = 0;
+        for ( j = 0; j < ASSIGNCOLS; j++ )
+            if ( assignedtableau[i][j] == 1 ) {
+                numassigns++;
+                break;
+            }
+        if ( numassigns == 0 )
+            linesrow[i] = 1;
+    }
 
-/*
-** linesrow[n]==0 indicate rows covered by imaginary line
-** linescol[n]==1 indicate cols covered by imaginary line
-** For all cells not covered by imaginary lines, determine smallest
-** value.
-*/
-smallest=MAXPOSLONG;
-for(i=0;i<ASSIGNROWS;i++)
-	if(linesrow[i]!=0)
-		for(j=0;j<ASSIGNCOLS;j++)
-			if(linescol[j]!=1)
-				if(tableau[i][j]<smallest)
-					smallest=tableau[i][j];
+    do {
 
-/*
-** Subtract smallest from all cells in the above set.
-*/
-for(i=0;i<ASSIGNROWS;i++)
-	if(linesrow[i]!=0)
-		for(j=0;j<ASSIGNCOLS;j++)
-			if(linescol[j]!=1)
-				tableau[i][j]-=smallest;
+        newrows = 0;
+        /*
+        ** For each row checked above, scan for any zeros.  If found,
+        ** check the associated column.
+        */
+        for ( i = 0; i < ASSIGNROWS; i++ ) {
+            if ( linesrow[i] == 1 )
+                for ( j = 0; j < ASSIGNCOLS; j++ )
+                    if ( tableau[i][j] == 0 )
+                        linescol[j] = 1;
+        }
+
+        /*
+        ** Now scan checked columns.  If any contain assigned zeros, check
+        ** the associated row.
+        */
+        for ( j = 0; j < ASSIGNCOLS; j++ )
+            if ( linescol[j] == 1 )
+                for ( i = 0; i < ASSIGNROWS; i++ )
+                    if ( (assignedtableau[i][j] == 1) && (linesrow[i] != 1) ) {
+                        linesrow[i] = 1;
+                        newrows++;
+                    }
+    } while ( newrows != 0 );
 
-/*
-** Add smallest to all cells covered by two lines.
-*/
-for(i=0;i<ASSIGNROWS;i++)
-	if(linesrow[i]==0)
-		for(j=0;j<ASSIGNCOLS;j++)
-			if(linescol[j]==1)
-				tableau[i][j]+=smallest;
+    /*
+    ** linesrow[n]==0 indicate rows covered by imaginary line
+    ** linescol[n]==1 indicate cols covered by imaginary line
+    ** For all cells not covered by imaginary lines, determine smallest
+    ** value.
+    */
+    smallest = MAXPOSLONG;
+    for ( i = 0; i < ASSIGNROWS; i++ )
+        if ( linesrow[i] != 0 )
+            for ( j = 0; j < ASSIGNCOLS; j++ )
+                if ( linescol[j] != 1 )
+                    if ( tableau[i][j] < smallest )
+                        smallest = tableau[i][j];
 
-return;
-}
+    /*
+    ** Subtract smallest from all cells in the above set.
+    */
+    for ( i = 0; i < ASSIGNROWS; i++ )
+        if ( linesrow[i] != 0 )
+            for ( j = 0; j < ASSIGNCOLS; j++ )
+                if ( linescol[j] != 1 )
+                    tableau[i][j] -= smallest;
+
+    /*
+    ** Add smallest to all cells covered by two lines.
+    */
+    for ( i = 0; i < ASSIGNROWS; i++ )
+        if ( linesrow[i] == 0 )
+            for ( j = 0; j < ASSIGNCOLS; j++ )
+                if ( linescol[j] == 1 )
+                    tableau[i][j] += smallest;
 
+    return;
+}
 
 /***************
 ** Assignment **
 ***************/
-static void Assignment(farlong arraybase[][ASSIGNCOLS])
-{
-short assignedtableau[ASSIGNROWS][ASSIGNCOLS];
+static void Assignment(farlong arraybase[][ASSIGNCOLS]) {
+    short assignedtableau[ASSIGNROWS][ASSIGNCOLS];
 
-/*
-** First, calculate minimum costs
-*/
-calc_minimum_costs(arraybase);
+    /*
+    ** First, calculate minimum costs
+    */
+    calc_minimum_costs(arraybase);
 
-/*
-** Repeat following until the number of rows selected
-** equals the number of rows in the tableau.
-*/
-while(first_assignments(arraybase,assignedtableau)!=ASSIGNROWS)
-{         second_assignments(arraybase,assignedtableau);
-}
-return;
+    /*
+    ** Repeat following until the number of rows selected
+    ** equals the number of rows in the tableau.
+    */
+    while ( first_assignments(arraybase, assignedtableau) != ASSIGNROWS ) {
+        second_assignments(arraybase, assignedtableau);
+    }
+    return;
 }
 
+void encl_call_AssignmentTest(unsigned int numarrays) {
+    longptr abase;
+    abase.ptrs.p = (long *)enclave_buffer;
+
+    for ( int i = 0; i < numarrays; i++ ) { /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
+                                            /* Fixed  by Eike Dierks */
+        Assignment(*abase.ptrs.ap);
+        abase.ptrs.p += ASSIGNROWS * ASSIGNCOLS;
+    }
+}
 
-void encl_call_AssignmentTest(unsigned int numarrays)
-{
-	longptr abase; 
-	abase.ptrs.p= (long *)enclave_buffer;	
-	
-
-for(int i=0;i<numarrays;i++)
-	{       /* abase.ptrs.p+=i*ASSIGNROWS*ASSIGNCOLS; */
-        	/* Fixed  by Eike Dierks */
-		Assignment(*abase.ptrs.ap);
-		abase.ptrs.p+=ASSIGNROWS*ASSIGNCOLS;
-	}
-
+void encl_app_loadIDEA(unsigned long arraysize) {
+    faruchar *plain1;
 
-}
+    for ( int i = 0; i < arraysize; i++ )
+        ((unsigned char *)(enclave_buffer))[i] = (uchar)(abs_randwc(255) & 0xFF);
 
-void encl_app_loadIDEA(unsigned long arraysize)
-{faruchar *plain1;
-	
-	for(int i=0;i<arraysize;i++)
-	((unsigned char *)(enclave_buffer))[i]=(uchar)(abs_randwc(255) & 0xFF);
-	
-	plain1=(unsigned char *)enclave_buffer;	
-	//printf("\nPlain1 Initialized: %d %d %d %d %d \n",plain1[0],plain1[1],plain1[2],plain1[3],plain1[4]);
+    plain1 = (unsigned char *)enclave_buffer;
+    // printf("\nPlain1 Initialized: %d %d %d %d %d \n",plain1[0],plain1[1],plain1[2],plain1[3],plain1[4]);
 }
 
 /********
@@ -2025,21 +1886,20 @@
 ** on the assumption that untaken branches are cheaper than taken
 ** branches, and that the compiler doesn't schedule branches.
 */
-static u16 mul(register u16 a, register u16 b)
-{
-register u32 p;
-if(a)
-{       if(b)
-	{       p=(u32)(a*b);
-		b=low16(p);
-		a=(u16)(p>>16);
-		return(b-a+(b<a));
-	}
-	else
-		return(1-a);
-}
-else
-	return(1-b);
+static u16 mul(register u16 a, register u16 b) {
+    register u32 p;
+    if ( a ) {
+        if ( b ) {
+            p = (u32)(a * b);
+            b = low16(p);
+            a = (u16)(p >> 16);
+            return (b - a + (b < a));
+        }
+        else
+            return (1 - a);
+    }
+    else
+        return (1 - b);
 }
 
 /****************
@@ -2047,123 +1907,107 @@
 *****************
 ** IDEA encryption/decryption algorithm.
 */
-static void cipher_idea(u16 in[4],
-		u16 out[4],
-		register IDEAkey Z)
-{
-
+static void cipher_idea(u16 in[4], u16 out[4], register IDEAkey Z) {
 
-
-register u16 x1, x2, x3, x4, t1, t2;
-/* register u16 t16;
-register u16 t32; */
-int r=ROUNDS;
-
-x1=*in++;
-x2=*in++;
-x3=*in++;
-x4=*in;
-
-do {
-	MUL(x1,*Z++);
-	x2+=*Z++;
-	x3+=*Z++;
-	MUL(x4,*Z++);
-
-	t2=x1^x3;
-	MUL(t2,*Z++);
-	t1=t2+(x2^x4);
-	MUL(t1,*Z++);
-	t2=t1+t2;
-
-	x1^=t1;
-	x4^=t2;
-
-	t2^=x2;
-	x2=x3^t1;
-	x3=t2;
-} while(--r);
-MUL(x1,*Z++);
-*out++=x1;
-*out++=x3+*Z++;
-*out++=x2+*Z++;
-MUL(x4,*Z);
-*out=x4;
-return;
+    register u16 x1, x2, x3, x4, t1, t2;
+    /* register u16 t16;
+    register u16 t32; */
+    int r = ROUNDS;
+
+    x1 = *in++;
+    x2 = *in++;
+    x3 = *in++;
+    x4 = *in;
+
+    do {
+        MUL(x1, *Z++);
+        x2 += *Z++;
+        x3 += *Z++;
+        MUL(x4, *Z++);
+
+        t2 = x1 ^ x3;
+        MUL(t2, *Z++);
+        t1 = t2 + (x2 ^ x4);
+        MUL(t1, *Z++);
+        t2 = t1 + t2;
+
+        x1 ^= t1;
+        x4 ^= t2;
+
+        t2 ^= x2;
+        x2 = x3 ^ t1;
+        x3 = t2;
+    } while ( --r );
+    MUL(x1, *Z++);
+    *out++ = x1;
+    *out++ = x3 + *Z++;
+    *out++ = x2 + *Z++;
+    MUL(x4, *Z);
+    *out = x4;
+    return;
 }
 
+void encl_callIDEA(unsigned long arraysize, unsigned short *Z, unsigned short *DK, unsigned long nloops) {
+    faruchar *plain1;
+    faruchar *crypt1;
+    faruchar *plain2;
+
+    register ulong i;
+    register ulong j;
+
+    plain1 = (unsigned char *)enclave_buffer;
+    crypt1 = (unsigned char *)enclave_buffer2;
+    plain2 = (unsigned char *)enclave_buffer3;
+
+    for ( int i = 0; i < nloops; i++ ) {
+        for ( j = 0; j < arraysize; j += (sizeof(u16) * 4) )
+            cipher_idea(((u16 *)(plain1 + j)), ((u16 *)(crypt1 + j)), Z); /* Encrypt */
 
-void encl_callIDEA(unsigned long arraysize, unsigned short * Z, unsigned short * DK, unsigned long nloops)
-{
-	faruchar *plain1;
-	faruchar *crypt1;
-	faruchar *plain2;
-	
-	register ulong i;
-	register ulong j;
-
-	plain1=(unsigned char *)enclave_buffer;
-	crypt1=(unsigned char *)enclave_buffer2;
-	plain2=(unsigned char *)enclave_buffer3;
-
-	for(int i=0;i<nloops;i++)
-	{
-		for(j=0;j<arraysize;j+=(sizeof(u16)*4))
-			cipher_idea(((u16 *)(plain1+j)),((u16 *)(crypt1+j)),Z);       /* Encrypt */
-
-		for(j=0;j<arraysize;j+=(sizeof(u16)*4))
-			cipher_idea(((u16 *)(crypt1+j)),((u16 *)(plain2+j)),DK);      /* Decrypt */
-	}	
+        for ( j = 0; j < arraysize; j += (sizeof(u16) * 4) )
+            cipher_idea(((u16 *)(crypt1 + j)), ((u16 *)(plain2 + j)), DK); /* Decrypt */
+    }
 }
 /* Neural Net */
-void encl_set_numpats(int npats)
-{
+void encl_set_numpats(int npats) {
     numpats = npats;
 }
 
-double encl_get_in_pats(int patt, int element)
-{
+double encl_get_in_pats(int patt, int element) {
     return in_pats[patt][element];
 }
 
-void encl_set_in_pats(int patt, int element, double val)
-{
+void encl_set_in_pats(int patt, int element, double val) {
     in_pats[patt][element] = val;
 }
 
-void encl_set_out_pats(int patt, int element, double val)
-{
+void encl_set_out_pats(int patt, int element, double val) {
     out_pats[patt][element] = val;
 }
 
-void encl_DoNNetIteration(unsigned long nloops)
-{
-int patt;
-randnum((int32)3);    /* Gotta do this for Neural Net */
-while(nloops--)
-{
-	randomize_wts();
-	zero_changes();
-	iteration_count=1;
-	learned = F;
-	numpasses = 0;
-	while (learned == F)
-	{
-		for (patt=0; patt<numpats; patt++)
-		{
-			worst_error = 0.0;      /* reset this every pass through data */
-			move_wt_changes();      /* move last pass's wt changes to momentum array */
-			do_forward_pass(patt);
-			do_back_pass(patt);
-			iteration_count++;
-		}
-		numpasses ++;
-		learned = check_out_error();
-	}
+void encl_DoNNetIteration(unsigned long nloops) {
+    int patt;
+    randnum((int32)3); /* Gotta do this for Neural Net */
+    while ( nloops-- ) {
+        randomize_wts();
+        zero_changes();
+        iteration_count = 1;
+        learned         = F;
+        numpasses       = 0;
+        while ( learned == F ) {
+            for ( patt = 0; patt < numpats; patt++ ) {
+                worst_error = 0.0; /* reset this every pass through data */
+                move_wt_changes(); /* move last pass's wt changes to momentum array */
+                do_forward_pass(patt);
+                do_back_pass(patt);
+                iteration_count++;
+            }
+            numpasses++;
+            learned = check_out_error();
+        }
 #ifdef DEBUG
-printf("Learned in %d passes\n",numpasses);
+        printf("Learned in %d passes\n", numpasses);
 #endif
-}
+    }
 }
 
 //////////////////////////////////////////LuDecomposition/////////////////////////////////////////////////////////
@@ -2178,63 +2022,60 @@
 ** row by a random number and (b) adding one randomly-selected
 ** row to another.
 */
-void encl_build_problem()
-{
-
-double *b= (double *)enclave_buffer2; 
-LUdblptr ptra;
-ptra.ptrs.p=(double *)enclave_buffer; 
-double (&a)[][LUARRAYCOLS] = *ptra.ptrs.ap;
+void encl_build_problem() {
 
-int n = LUARRAYROWS;
+    double * b = (double *)enclave_buffer2;
+    LUdblptr ptra;
+    ptra.ptrs.p               = (double *)enclave_buffer;
+    double(&a)[][LUARRAYCOLS] = *ptra.ptrs.ap;
 
-long i,j,k,k1;  /* Indexes */
-double rcon;     /* Random constant */
+    int n = LUARRAYROWS;
 
-/*
-** Reset random number generator
-*/
-/* randnum(13L); */
-randnum((int32)13);
-
-/*
-** Build an identity matrix.
-** We'll also use this as a chance to load the solution
-** vector.
-*/
-for(i=0;i<n;i++)
-{       /* b[i]=(double)(abs_randwc(100L)+1L); */
-	b[i]=(double)(abs_randwc((int32)100)+(int32)1);
-	for(j=0;j<n;j++)
-		if(i==j)
-		        /* a[i][j]=(double)(abs_randwc(1000L)+1L); */
-			a[i][j]=(double)(abs_randwc((int32)1000)+(int32)1);
-		else
-			a[i][j]=(double)0.0;
-}
+    long   i, j, k, k1; /* Indexes */
+    double rcon;        /* Random constant */
 
+    /*
+    ** Reset random number generator
+    */
+    /* randnum(13L); */
+    randnum((int32)13);
 
-/*
-** Scramble.  Do this 8n times.  See comment above for
-** a description of the scrambling process.
-*/
+    /*
+    ** Build an identity matrix.
+    ** We'll also use this as a chance to load the solution
+    ** vector.
+    */
+    for ( i = 0; i < n; i++ ) { /* b[i]=(double)(abs_randwc(100L)+1L); */
+        b[i] = (double)(abs_randwc((int32)100) + (int32)1);
+        for ( j = 0; j < n; j++ )
+            if ( i == j )
+                /* a[i][j]=(double)(abs_randwc(1000L)+1L); */
+                a[i][j] = (double)(abs_randwc((int32)1000) + (int32)1);
+            else
+                a[i][j] = (double)0.0;
+    }
 
+    /*
+    ** Scramble.  Do this 8n times.  See comment above for
+    ** a description of the scrambling process.
+    */
 
-for(i=0;i<8*n;i++)
-{
-	k=abs_randwc((int32)n);
-	k1=abs_randwc((int32)n);
-	if(k!=k1)
-	{
-		if(k<k1) rcon=(double)1.0;
-			else rcon=(double)-1.0;
-		for(j=0;j<n;j++)
-			a[k][j]+=a[k1][j]*rcon;;
-		b[k]+=b[k1]*rcon;
-	}
-}
+    for ( i = 0; i < 8 * n; i++ ) {
+        k  = abs_randwc((int32)n);
+        k1 = abs_randwc((int32)n);
+        if ( k != k1 ) {
+            if ( k < k1 )
+                rcon = (double)1.0;
+            else
+                rcon = (double)-1.0;
+            for ( j = 0; j < n; j++ )
+                a[k][j] += a[k1][j] * rcon;
+            ;
+            b[k] += b[k1] * rcon;
+        }
+    }
 
-return;
+    return;
 }
 
 /***********
@@ -2265,87 +2106,84 @@
 ** respectively.
 ** Returns 0 if matrix singular, else returns 1.
 */
-static int ludcmp(double a[][LUARRAYCOLS],
-		int n,
-		int indx[],
-		int *d)
-{
+static int ludcmp(double a[][LUARRAYCOLS], int n, int indx[], int *d) {
 
-double big;     /* Holds largest element value */
-double sum;
-double dum;     /* Holds dummy value */
-int i,j,k;      /* Indexes */
-int imax=0;     /* Holds max index value */
-double tiny;    /* A really small number */
-fardouble *LUtempvv=(double *)enclave_buffer;
-tiny=(double)1.0e-20;
-
-*d=1;           /* No interchanges yet */
-
-for(i=0;i<n;i++)
-{       big=(double)0.0;
-	for(j=0;j<n;j++)
-		if((double)fabs(a[i][j]) > big)
-			big=fabs(a[i][j]);
-	/* Bail out on singular matrix */
-	if(big==(double)0.0) return(0);
-	LUtempvv[i]=1.0/big;
-}
+    double     big; /* Holds largest element value */
+    double     sum;
+    double     dum;      /* Holds dummy value */
+    int        i, j, k;  /* Indexes */
+    int        imax = 0; /* Holds max index value */
+    double     tiny;     /* A really small number */
+    fardouble *LUtempvv = (double *)enclave_buffer;
+    tiny                = (double)1.0e-20;
+
+    *d = 1; /* No interchanges yet */
+
+    for ( i = 0; i < n; i++ ) {
+        big = (double)0.0;
+        for ( j = 0; j < n; j++ )
+            if ( (double)fabs(a[i][j]) > big )
+                big = fabs(a[i][j]);
+        /* Bail out on singular matrix */
+        if ( big == (double)0.0 )
+            return (0);
+        LUtempvv[i] = 1.0 / big;
+    }
 
-/*
-** Crout's algorithm...loop over columns.
-*/
-for(j=0;j<n;j++)
-{       if(j!=0)
-		for(i=0;i<j;i++)
-		{       sum=a[i][j];
-			if(i!=0)
-				for(k=0;k<i;k++)
-					sum-=(a[i][k]*a[k][j]);
-			a[i][j]=sum;
-		}
-	big=(double)0.0;
-	for(i=j;i<n;i++)
-	{       sum=a[i][j];
-		if(j!=0)
-			for(k=0;k<j;k++)
-				sum-=a[i][k]*a[k][j];
-		a[i][j]=sum;
-		dum=LUtempvv[i]*fabs(sum);
-		if(dum>=big)
-		{       big=dum;
-			imax=i;
-		}
-	}
-	if(j!=imax)             /* Interchange rows if necessary */
-	{       for(k=0;k<n;k++)
-		{       dum=a[imax][k];
-			a[imax][k]=a[j][k];
-			a[j][k]=dum;
-		}
-		*d=-*d;         /* Change parity of d */
-		dum=LUtempvv[imax];
-		LUtempvv[imax]=LUtempvv[j]; /* Don't forget scale factor */
-		LUtempvv[j]=dum;
-	}
-	indx[j]=imax;
-	/*
-	** If the pivot element is zero, the matrix is singular
-	** (at least as far as the precision of the machine
-	** is concerned.)  We'll take the original author's
-	** recommendation and replace 0.0 with "tiny".
-	*/
-	if(a[j][j]==(double)0.0)
-		a[j][j]=tiny;
-
-	if(j!=(n-1))
-	{       dum=1.0/a[j][j];
-		for(i=j+1;i<n;i++)
-			a[i][j]=a[i][j]*dum;
-	}
-}
+    /*
+    ** Crout's algorithm...loop over columns.
+    */
+    for ( j = 0; j < n; j++ ) {
+        if ( j != 0 )
+            for ( i = 0; i < j; i++ ) {
+                sum = a[i][j];
+                if ( i != 0 )
+                    for ( k = 0; k < i; k++ )
+                        sum -= (a[i][k] * a[k][j]);
+                a[i][j] = sum;
+            }
+        big = (double)0.0;
+        for ( i = j; i < n; i++ ) {
+            sum = a[i][j];
+            if ( j != 0 )
+                for ( k = 0; k < j; k++ )
+                    sum -= a[i][k] * a[k][j];
+            a[i][j] = sum;
+            dum     = LUtempvv[i] * fabs(sum);
+            if ( dum >= big ) {
+                big  = dum;
+                imax = i;
+            }
+        }
+        if ( j != imax ) /* Interchange rows if necessary */ {
+            for ( k = 0; k < n; k++ ) {
+                dum        = a[imax][k];
+                a[imax][k] = a[j][k];
+                a[j][k]    = dum;
+            }
+            *d             = -*d; /* Change parity of d */
+            dum            = LUtempvv[imax];
+            LUtempvv[imax] = LUtempvv[j]; /* Don't forget scale factor */
+            LUtempvv[j]    = dum;
+        }
+        indx[j] = imax;
+        /*
+        ** If the pivot element is zero, the matrix is singular
+        ** (at least as far as the precision of the machine
+        ** is concerned.)  We'll take the original author's
+        ** recommendation and replace 0.0 with "tiny".
+        */
+        if ( a[j][j] == (double)0.0 )
+            a[j][j] = tiny;
+
+        if ( j != (n - 1) ) {
+            dum = 1.0 / a[j][j];
+            for ( i = j + 1; i < n; i++ )
+                a[i][j] = a[i][j] * dum;
+        }
+    }
 
-return(1);
+    return (1);
 }
 
 /***********
@@ -2364,52 +2202,47 @@
 ** begin with many zero elements, so it is efficient for use in
 ** matrix inversion.
 */
-static void lubksb( double a[][LUARRAYCOLS],
-		int n,
-		int indx[LUARRAYROWS],
-		double b[LUARRAYROWS])
-{
+static void lubksb(double a[][LUARRAYCOLS], int n, int indx[LUARRAYROWS], double b[LUARRAYROWS]) {
 
-int i,j;        /* Indexes */
-int ip;         /* "pointer" into indx */
-int ii;
-double sum;
+    int    i, j; /* Indexes */
+    int    ip;   /* "pointer" into indx */
+    int    ii;
+    double sum;
 
-/*
-** When ii is set to a positive value, it will become
-** the index of the first nonvanishing element of b[].
-** We now do the forward substitution. The only wrinkle
-** is to unscramble the permutation as we go.
-*/
-ii=-1;
-for(i=0;i<n;i++)
-{       ip=indx[i];
-	sum=b[ip];
-	b[ip]=b[i];
-	if(ii!=-1)
-		for(j=ii;j<i;j++)
-			sum=sum-a[i][j]*b[j];
-	else
-		/*
-		** If a nonzero element is encountered, we have
-		** to do the sums in the loop above.
-		*/
-		if(sum!=(double)0.0)
-			ii=i;
-	b[i]=sum;
-}
-/*
-** Do backsubstitution
-*/
-for(i=(n-1);i>=0;i--)
-{
-	sum=b[i];
-	if(i!=(n-1))
-		for(j=(i+1);j<n;j++)
-			sum=sum-a[i][j]*b[j];
-	b[i]=sum/a[i][i];
-}
-return;
+    /*
+    ** When ii is set to a positive value, it will become
+    ** the index of the first nonvanishing element of b[].
+    ** We now do the forward substitution. The only wrinkle
+    ** is to unscramble the permutation as we go.
+    */
+    ii = -1;
+    for ( i = 0; i < n; i++ ) {
+        ip    = indx[i];
+        sum   = b[ip];
+        b[ip] = b[i];
+        if ( ii != -1 )
+            for ( j = ii; j < i; j++ )
+                sum = sum - a[i][j] * b[j];
+        else
+            /*
+            ** If a nonzero element is encountered, we have
+            ** to do the sums in the loop above.
+            */
+            if ( sum != (double)0.0 )
+            ii = i;
+        b[i] = sum;
+    }
+    /*
+    ** Do backsubstitution
+    */
+    for ( i = (n - 1); i >= 0; i-- ) {
+        sum = b[i];
+        if ( i != (n - 1) )
+            for ( j = (i + 1); j < n; j++ )
+                sum = sum - a[i][j] * b[j];
+        b[i] = sum / a[i][i];
+    }
+    return;
 }
 
 /************
@@ -2419,121 +2252,102 @@
 ** Original matrix A will be destroyed by this operation.
 ** Returns 0 if matrix is singular, 1 otherwise.
 */
-static int lusolve(double a[][LUARRAYCOLS],
-		int n,
-		double b[LUARRAYROWS])
-{
-int indx[LUARRAYROWS];
-int d;
+static int lusolve(double a[][LUARRAYCOLS], int n, double b[LUARRAYROWS]) {
+    int indx[LUARRAYROWS];
+    int d;
 #ifdef DEBUG
-int i,j;
+    int i, j;
 #endif
 
+    if ( ludcmp(a, n, indx, &d) == 0 )
+        return (0);
 
-if(ludcmp(a,n,indx,&d)==0) return(0);
-
-/* Matrix not singular -- proceed */
-lubksb(a,n,indx,b);
-//printf("hello\n");
+    /* Matrix not singular -- proceed */
+    lubksb(a, n, indx, b);
+// printf("hello\n");
 #ifdef DEBUG
-printf("Solution:\n");
-for(i=0;i<n;i++)
-{
-  for(j=0;j<n;j++){
-  /*
-    printf("%6.2f ",a[i][j]);
-  */
-  }
-  printf("%6.2f\t",b[i]);
-  /*
+    printf("Solution:\n");
+    for ( i = 0; i < n; i++ ) {
+        for ( j = 0; j < n; j++ ) {
+            /*
+              printf("%6.2f ",a[i][j]);
+            */
+        }
+        printf("%6.2f\t", b[i]);
+        /*
+          printf("\n");
+        */
+    }
     printf("\n");
-  */
-}
-printf("\n");
 #endif
 
-return(1);
-}
-
-
-
-void encl_moveSeedArrays(unsigned long numarrays)
-{
-fardouble *a=(double *)enclave_buffer;
-fardouble *b=(double *)enclave_buffer2;
-fardouble *abase=(double *)enclave_buffer4;
-fardouble *bbase=(double *)enclave_buffer5;
-fardouble *locabase;
-fardouble *locbbase;
-ulong j,i; 
-
-for(j=0;j<numarrays;j++)
-	{       locabase=abase+j*LUARRAYROWS*LUARRAYCOLS;
-		locbbase=bbase+j*LUARRAYROWS;
-		for(i=0;i<LUARRAYROWS*LUARRAYCOLS;i++)
-			*(locabase+i)=*(a+i);
-		for(i=0;i<LUARRAYROWS;i++)
-			*(locbbase+i)=*(b+i);
-	}
-
+    return (1);
 }
 
-
-void encl_call_lusolve(unsigned long numarrays)
-{
-fardouble *a=(double *)enclave_buffer;
-fardouble *b=(double *)enclave_buffer2;
-fardouble *abase=(double *)enclave_buffer4;
-fardouble *bbase=(double *)enclave_buffer5;
-fardouble *locabase;
-fardouble *locbbase;
-ulong i; 
-LUdblptr ptra;
-//ptra.ptrs.p=(double *)enclave_buffer; 
-
-
-
-for(i=0;i<numarrays;i++)
-{       locabase=abase+i*LUARRAYROWS*LUARRAYCOLS;
-	locbbase=bbase+i*LUARRAYROWS;
-	ptra.ptrs.p=locabase;
-	lusolve(*ptra.ptrs.ap,LUARRAYROWS,locbbase);
+void encl_moveSeedArrays(unsigned long numarrays) {
+    fardouble *a     = (double *)enclave_buffer;
+    fardouble *b     = (double *)enclave_buffer2;
+    fardouble *abase = (double *)enclave_buffer4;
+    fardouble *bbase = (double *)enclave_buffer5;
+    fardouble *locabase;
+    fardouble *locbbase;
+    ulong      j, i;
+
+    for ( j = 0; j < numarrays; j++ ) {
+        locabase = abase + j * LUARRAYROWS * LUARRAYCOLS;
+        locbbase = bbase + j * LUARRAYROWS;
+        for ( i = 0; i < LUARRAYROWS * LUARRAYCOLS; i++ )
+            *(locabase + i) = *(a + i);
+        for ( i = 0; i < LUARRAYROWS; i++ )
+            *(locbbase + i) = *(b + i);
+    }
 }
 
-
+void encl_call_lusolve(unsigned long numarrays) {
+    fardouble *a     = (double *)enclave_buffer;
+    fardouble *b     = (double *)enclave_buffer2;
+    fardouble *abase = (double *)enclave_buffer4;
+    fardouble *bbase = (double *)enclave_buffer5;
+    fardouble *locabase;
+    fardouble *locbbase;
+    ulong      i;
+    LUdblptr   ptra;
+    // ptra.ptrs.p=(double *)enclave_buffer;
+
+    for ( i = 0; i < numarrays; i++ ) {
+        locabase    = abase + i * LUARRAYROWS * LUARRAYCOLS;
+        locbbase    = bbase + i * LUARRAYROWS;
+        ptra.ptrs.p = locabase;
+        lusolve(*ptra.ptrs.ap, LUARRAYROWS, locbbase);
+    }
 }
 
-
-
 /***************
 ** SetCompBit **
 ****************
 ** Set a bit in the compression array.  The value of the
 ** bit is set according to char bitchar.
 */
-static void SetCompBit(u8 *comparray,
-		u32 bitoffset,
-		char bitchar)
-{
-u32 byteoffset;
-int bitnumb;
+static void SetCompBit(u8 *comparray, u32 bitoffset, char bitchar) {
+    u32 byteoffset;
+    int bitnumb;
 
-/*
-** First calculate which element in the comparray to
-** alter. and the bitnumber.
-*/
-byteoffset=bitoffset>>3;
-bitnumb=bitoffset % 8;
+    /*
+    ** First calculate which element in the comparray to
+    ** alter. and the bitnumber.
+    */
+    byteoffset = bitoffset >> 3;
+    bitnumb    = bitoffset % 8;
 
-/*
-** Set or clear
-*/
-if(bitchar=='1')
-	comparray[byteoffset]|=(1<<bitnumb);
-else
-	comparray[byteoffset]&=~(1<<bitnumb);
+    /*
+    ** Set or clear
+    */
+    if ( bitchar == '1' )
+        comparray[byteoffset] |= (1 << bitnumb);
+    else
+        comparray[byteoffset] &= ~(1 << bitnumb);
 
-return;
+    return;
 }
 /*********************
 ** create_text_line **
@@ -2541,51 +2355,47 @@
 ** Create a random line of text, stored at *dt.  The line may be
 ** no more than nchars long.
 */
-static void create_text_line(farchar *dt,
-			long nchars)
-{
-long charssofar;        /* # of characters so far */
-long tomove;            /* # of characters to move */
-char myword[40];        /* Local buffer for words */
-farchar *wordptr;       /* Pointer to word from catalog */
-
-charssofar=0;
-
-do {
-/*
-** Grab a random word from the wordcatalog
-*/
-/* wordptr=wordcatarray[abs_randwc((long)WORDCATSIZE)];*/
-wordptr=wordcatarray[abs_randwc((int32)WORDCATSIZE)];
-MoveMemory((farvoid *)myword,
-	(farvoid *)wordptr,
-	(unsigned long)strlen(wordptr)+1);
-
-/*
-** Append a blank.
-*/
-tomove=strlen(myword)+1;
-myword[tomove-1]=' ';
-
-/*
-** See how long it is.  If its length+charssofar > nchars, we have
-** to trim it.
-*/
-if((tomove+charssofar)>nchars)
-	tomove=nchars-charssofar;
-/*
-** Attach the word to the current line.  Increment counter.
-*/
-MoveMemory((farvoid *)dt,(farvoid *)myword,(unsigned long)tomove);
-charssofar+=tomove;
-dt+=tomove;
-
-/*
-** If we're done, bail out.  Otherwise, go get another word.
-*/
-} while(charssofar<nchars);
+static void create_text_line(farchar *dt, long nchars) {
+    long     charssofar; /* # of characters so far */
+    long     tomove;     /* # of characters to move */
+    char     myword[40]; /* Local buffer for words */
+    farchar *wordptr;    /* Pointer to word from catalog */
+
+    charssofar = 0;
+
+    do {
+        /*
+        ** Grab a random word from the wordcatalog
+        */
+        /* wordptr=wordcatarray[abs_randwc((long)WORDCATSIZE)];*/
+        wordptr = wordcatarray[abs_randwc((int32)WORDCATSIZE)];
+        MoveMemory((farvoid *)myword, (farvoid *)wordptr, (unsigned long)strlen(wordptr) + 1);
+
+        /*
+        ** Append a blank.
+        */
+        tomove             = strlen(myword) + 1;
+        myword[tomove - 1] = ' ';
+
+        /*
+        ** See how long it is.  If its length+charssofar > nchars, we have
+        ** to trim it.
+        */
+        if ( (tomove + charssofar) > nchars )
+            tomove = nchars - charssofar;
+        /*
+        ** Attach the word to the current line.  Increment counter.
+        */
+        MoveMemory((farvoid *)dt, (farvoid *)myword, (unsigned long)tomove);
+        charssofar += tomove;
+        dt += tomove;
+
+        /*
+        ** If we're done, bail out.  Otherwise, go get another word.
+        */
+    } while ( charssofar < nchars );
 
-return;
+    return;
 }
 
 /**********************
@@ -2599,38 +2409,32 @@
 ** maxlinlen is the maximum length of any line (line end indicated
 **  by a carriage return).
 */
-static void create_text_block(farchar *tb,
-			ulong tblen,
-			ushort maxlinlen)
-{
-ulong bytessofar;       /* # of bytes so far */
-ulong linelen;          /* Line length */
+static void create_text_block(farchar *tb, ulong tblen, ushort maxlinlen) {
+    ulong bytessofar; /* # of bytes so far */
+    ulong linelen;    /* Line length */
+
+    bytessofar = 0L;
+    do {
+
+        /*
+        ** Pick a random length for a line and fill the line.
+        ** Make sure the line can fit (haven't exceeded tablen) and also
+        ** make sure you leave room to append a carriage return.
+        */
+        linelen = abs_randwc(maxlinlen - 6) + 6;
+        if ( (linelen + bytessofar) > tblen )
+            linelen = tblen - bytessofar;
+
+        if ( linelen > 1 ) {
+            create_text_line(tb, linelen);
+        }
+        tb += linelen - 1; /* Add the carriage return */
+        *tb++ = '\n';
 
-bytessofar=0L;
-do {
+        bytessofar += linelen;
 
-/*
-** Pick a random length for a line and fill the line.
-** Make sure the line can fit (haven't exceeded tablen) and also
-** make sure you leave room to append a carriage return.
-*/
-linelen=abs_randwc(maxlinlen-6)+6;
-if((linelen+bytessofar)>tblen)
-	linelen=tblen-bytessofar;
-
-if(linelen>1)
-{
-	create_text_line(tb,linelen);
+    } while ( bytessofar < tblen );
 }
-tb+=linelen-1;          /* Add the carriage return */
-*tb++='\n';
-
-bytessofar+=linelen;
-
-} while(bytessofar<tblen);
-
-}
-
 
 /***************
 ** GetCompBit **
@@ -2638,256 +2442,215 @@
 ** Return the bit value of a bit in the comparession array.
 ** Returns 0 if the bit is clear, nonzero otherwise.
 */
-static int GetCompBit(u8 *comparray,
-		u32 bitoffset)
-{
-u32 byteoffset;
-int bitnumb;
-
-/*
-** Calculate byte offset and bit number.
-*/
-byteoffset=bitoffset>>3;
-bitnumb=bitoffset % 8;
+static int GetCompBit(u8 *comparray, u32 bitoffset) {
+    u32 byteoffset;
+    int bitnumb;
 
-/*
-** Fetch
-*/
-return((1<<bitnumb) & comparray[byteoffset] );
-}
-
-
-
-void encl_buildHuffman(unsigned long arraysize)
-{
-
-	HuffStruct *lochuffstruct;      /* Loc pointer to global data */
-	farchar *plaintext;
-	plaintext = (char *)enclave_buffer;	
-
-	//lochuffstruct={0,0,arraysize,0,0};
-
-	randnum((int32)13);
-
-	create_text_block(plaintext,arraysize-1,(ushort)500);
-	plaintext[arraysize-1L]='\0';
-	plaintextlen=arraysize;
+    /*
+    ** Calculate byte offset and bit number.
+    */
+    byteoffset = bitoffset >> 3;
+    bitnumb    = bitoffset % 8;
 
+    /*
+    ** Fetch
+    */
+    return ((1 << bitnumb) & comparray[byteoffset]);
 }
 
+void encl_buildHuffman(unsigned long arraysize) {
 
+    HuffStruct *lochuffstruct; /* Loc pointer to global data */
+    farchar *   plaintext;
+    plaintext = (char *)enclave_buffer;
+
+    // lochuffstruct={0,0,arraysize,0,0};
+
+    randnum((int32)13);
+
+    create_text_block(plaintext, arraysize - 1, (ushort)500);
+    plaintext[arraysize - 1L] = '\0';
+    plaintextlen              = arraysize;
+}
+
+void encl_callHuffman(unsigned long nloops, unsigned long arraysize) {
+    farchar *  plaintext;
+    farchar *  comparray;
+    farchar *  decomparray;
+    huff_node *hufftree;
+
+    plaintext   = (char *)enclave_buffer;
+    comparray   = (char *)enclave_buffer2;
+    decomparray = (char *)enclave_buffer3;
+    hufftree    = (huff_node *)enclave_buffer4;
+
+    int   i;                  /* Index */
+    long  j;                  /* Bigger index */
+    int   root;               /* Pointer to huffman tree root */
+    float lowfreq1, lowfreq2; /* Low frequency counters */
+    int   lowidx1, lowidx2;   /* Indexes of low freq. elements */
+    long  bitoffset;          /* Bit offset into text */
+    long  textoffset;         /* Char offset into text */
+    long  maxbitoffset;       /* Holds limit of bit offset */
+    long  bitstringlen;       /* Length of bitstring */
+    int   c;                  /* Character from plaintext */
+    char  bitstring[30];      /* Holds bitstring */
+    ulong elapsed;
+
+    while ( nloops-- ) {
+
+        /*
+        ** Calculate the frequency of each byte value. Store the
+        ** results in what will become the "leaves" of the
+        ** Huffman tree.  Interior nodes will be built in those
+        ** nodes greater than node #255.
+        */
+
+        for ( i = 0; i < 256; i++ ) {
+            hufftree[i].freq = (float)0.0;
+            hufftree[i].c    = (unsigned char)i;
+        }
+
+        for ( j = 0; j < arraysize; j++ )
+            hufftree[(int)plaintext[j]].freq += (float)1.0;
+
+        for ( i = 0; i < 256; i++ )
+            if ( hufftree[i].freq != (float)0.0 )
+                hufftree[i].freq /= (float)arraysize;
+
+        /* Reset the second half of the tree. Otherwise the loop below that
+        ** compares the frequencies up to index 512 makes no sense. Some
+        ** systems automatically zero out memory upon allocation, others (like
+        ** for example DEC Unix) do not. Depending on this the loop below gets
+        ** different data and different run times. On our alpha the data that
+        ** was arbitrarily assigned led to an underflow error at runtime. We
+        ** use that zeroed-out bits are in fact 0 as a float.
+        ** Uwe F. Mayer */
+        bzero((char *)&(hufftree[256]), sizeof(huff_node) * 256);
+        /*
+        ** Build the huffman tree.  First clear all the parent
+        ** pointers and left/right pointers.  Also, discard all
+        ** nodes that have a frequency of true 0.  */
+        for ( i = 0; i < 512; i++ ) {
+            if ( hufftree[i].freq == (float)0.0 )
+                hufftree[i].parent = EXCLUDED;
+            else
+                hufftree[i].parent = hufftree[i].left = hufftree[i].right = -1;
+        }
+
+        /*
+        ** Go through the tree. Finding nodes of really low
+        ** frequency.
+        */
+        root = 255; /* Starting root node-1 */
+        while ( 1 ) {
+            lowfreq1 = (float)2.0;
+            lowfreq2 = (float)2.0;
+            lowidx1  = -1;
+            lowidx2  = -1;
+            /*
+            ** Find first lowest frequency.
+            */
+            for ( i = 0; i <= root; i++ )
+                if ( hufftree[i].parent < 0 )
+                    if ( hufftree[i].freq < lowfreq1 ) {
+                        lowfreq1 = hufftree[i].freq;
+                        lowidx1  = i;
+                    }
 
-void encl_callHuffman(unsigned long nloops, unsigned long arraysize)
-{
-	farchar *plaintext;
-	farchar *comparray;	
-	farchar *decomparray;
-	huff_node * hufftree;
-
-
-	plaintext = (char *)enclave_buffer;	
-	comparray = (char *)enclave_buffer2;
-	decomparray = (char *)enclave_buffer3;
-	hufftree = (huff_node *)enclave_buffer4;
-
-
-	int i;                          /* Index */
-	long j;                         /* Bigger index */
-	int root;                       /* Pointer to huffman tree root */
-	float lowfreq1, lowfreq2;       /* Low frequency counters */
-	int lowidx1, lowidx2;           /* Indexes of low freq. elements */
-	long bitoffset;                 /* Bit offset into text */
-	long textoffset;                /* Char offset into text */
-	long maxbitoffset;              /* Holds limit of bit offset */
-	long bitstringlen;              /* Length of bitstring */
-	int c;                          /* Character from plaintext */
-	char bitstring[30];             /* Holds bitstring */
-	ulong elapsed; 
-
-
-
-
-
-
-
-while(nloops--)
-{
-
-
-/*
-** Calculate the frequency of each byte value. Store the
-** results in what will become the "leaves" of the
-** Huffman tree.  Interior nodes will be built in those
-** nodes greater than node #255.
-*/
-
-for(i=0;i<256;i++)
-{		
-	hufftree[i].freq=(float)0.0;
-	hufftree[i].c=(unsigned char)i;
+            /*
+            ** Did we find a lowest value?  If not, the
+            ** tree is done.
+            */
+            if ( lowidx1 == -1 )
+                break;
 
-}
+            /*
+            ** Find next lowest frequency
+            */
+            for ( i = 0; i <= root; i++ )
+                if ( (hufftree[i].parent < 0) && (i != lowidx1) )
+                    if ( hufftree[i].freq < lowfreq2 ) {
+                        lowfreq2 = hufftree[i].freq;
+                        lowidx2  = i;
+                    }
 
-for(j=0;j<arraysize;j++)
-	hufftree[(int)plaintext[j]].freq+=(float)1.0;
-
-for(i=0;i<256;i++)
-	if(hufftree[i].freq != (float)0.0)
-		hufftree[i].freq/=(float)arraysize;
-
-/* Reset the second half of the tree. Otherwise the loop below that
-** compares the frequencies up to index 512 makes no sense. Some
-** systems automatically zero out memory upon allocation, others (like
-** for example DEC Unix) do not. Depending on this the loop below gets
-** different data and different run times. On our alpha the data that
-** was arbitrarily assigned led to an underflow error at runtime. We
-** use that zeroed-out bits are in fact 0 as a float.
-** Uwe F. Mayer */
-bzero((char *)&(hufftree[256]),sizeof(huff_node)*256);
-/*
-** Build the huffman tree.  First clear all the parent
-** pointers and left/right pointers.  Also, discard all
-** nodes that have a frequency of true 0.  */
-for(i=0;i<512;i++)
-{       if(hufftree[i].freq==(float)0.0)
-		hufftree[i].parent=EXCLUDED;
-	else
-		hufftree[i].parent=hufftree[i].left=hufftree[i].right=-1;
-}
+            /*
+            ** If we could only find one item, then that
+            ** item is surely the root, and (as above) the
+            ** tree is done.
+            */
+            if ( lowidx2 == -1 )
+                break;
 
-/*
-** Go through the tree. Finding nodes of really low
-** frequency.
-*/
-root=255;                       /* Starting root node-1 */
-while(1)
-{
-	lowfreq1=(float)2.0; lowfreq2=(float)2.0;
-	lowidx1=-1; lowidx2=-1;
-	/*
-	** Find first lowest frequency.
-	*/
-	for(i=0;i<=root;i++)
-		if(hufftree[i].parent<0)
-			if(hufftree[i].freq<lowfreq1)
-			{       lowfreq1=hufftree[i].freq;
-				lowidx1=i;
-			}
-
-	/*
-	** Did we find a lowest value?  If not, the
-	** tree is done.
-	*/
-	if(lowidx1==-1) break;
-
-	/*
-	** Find next lowest frequency
-	*/
-	for(i=0;i<=root;i++)
-		if((hufftree[i].parent<0) && (i!=lowidx1))
-			if(hufftree[i].freq<lowfreq2)
-			{       lowfreq2=hufftree[i].freq;
-				lowidx2=i;
-			}
-
-	/*
-	** If we could only find one item, then that
-	** item is surely the root, and (as above) the
-	** tree is done.
-	*/
-	if(lowidx2==-1) break;
-
-	/*
-	** Attach the two new nodes to the current root, and
-	** advance the current root.
-	*/
-	root++;                 /* New root */
-	hufftree[lowidx1].parent=root;
-	hufftree[lowidx2].parent=root;
-	hufftree[root].freq=lowfreq1+lowfreq2;
-	hufftree[root].left=lowidx1;
-	hufftree[root].right=lowidx2;
-	hufftree[root].parent=-2;       /* Show root */
-}
+            /*
+            ** Attach the two new nodes to the current root, and
+            ** advance the current root.
+            */
+            root++; /* New root */
+            hufftree[lowidx1].parent = root;
+            hufftree[lowidx2].parent = root;
+            hufftree[root].freq      = lowfreq1 + lowfreq2;
+            hufftree[root].left      = lowidx1;
+            hufftree[root].right     = lowidx2;
+            hufftree[root].parent    = -2; /* Show root */
+        }
+
+        /*
+        ** Huffman tree built...compress the plaintext
+        */
+        bitoffset = 0L; /* Initialize bit offset */
+        for ( i = 0; i < arraysize; i++ ) {
+            c = (int)plaintext[i]; /* Fetch character */
+            /*
+            ** Build a bit string for byte c
+            */
+            bitstringlen = 0;
+            while ( hufftree[c].parent != -2 ) {
+                if ( hufftree[hufftree[c].parent].left == c )
+                    bitstring[bitstringlen] = '0';
+                else
+                    bitstring[bitstringlen] = '1';
+                c = hufftree[c].parent;
+                bitstringlen++;
+            }
 
-/*
-** Huffman tree built...compress the plaintext
-*/
-bitoffset=0L;                           /* Initialize bit offset */
-for(i=0;i<arraysize;i++)
-{
-	c=(int)plaintext[i];                 /* Fetch character */
-	/*
-	** Build a bit string for byte c
-	*/
-	bitstringlen=0;
-	while(hufftree[c].parent!=-2)
-	{       if(hufftree[hufftree[c].parent].left==c)
-			bitstring[bitstringlen]='0';
-		else
-			bitstring[bitstringlen]='1';
-		c=hufftree[c].parent;
-		bitstringlen++;
-	}
-
-	/*
-	** Step backwards through the bit string, setting
-	** bits in the compressed array as you go.
-	*/
-	while(bitstringlen--)
-	{       SetCompBit((u8 *)comparray,(u32)bitoffset,bitstring[bitstringlen]);
-		bitoffset++;
-	}
-}
+            /*
+            ** Step backwards through the bit string, setting
+            ** bits in the compressed array as you go.
+            */
+            while ( bitstringlen-- ) {
+                SetCompBit((u8 *)comparray, (u32)bitoffset, bitstring[bitstringlen]);
+                bitoffset++;
+            }
+        }
 
-/*
-** Compression done.  Perform de-compression.
-*/
-maxbitoffset=bitoffset;
-bitoffset=0;
-textoffset=0;
-do {
-	i=root;
-	while(hufftree[i].left!=-1)
-	{       if(GetCompBit((u8 *)comparray,(u32)bitoffset)==0)
-			i=hufftree[i].left;
-		else
-			i=hufftree[i].right;
-		bitoffset++;
-	}
-	decomparray[textoffset]=hufftree[i].c;
+        /*
+        ** Compression done.  Perform de-compression.
+        */
+        maxbitoffset = bitoffset;
+        bitoffset    = 0;
+        textoffset   = 0;
+        do {
+            i = root;
+            while ( hufftree[i].left != -1 ) {
+                if ( GetCompBit((u8 *)comparray, (u32)bitoffset) == 0 )
+                    i = hufftree[i].left;
+                else
+                    i = hufftree[i].right;
+                bitoffset++;
+            }
+            decomparray[textoffset] = hufftree[i].c;
 
 #ifdef DEBUG
-	if(hufftree[i].c != plaintext[textoffset])
-	{
-		/* Show error */
-		printf("Error at textoffset %ld\n",textoffset);
-		status=1;
-	}
+            if ( hufftree[i].c != plaintext[textoffset] ) {
+                /* Show error */
+                printf("Error at textoffset %ld\n", textoffset);
+                status = 1;
+            }
 #endif
-	textoffset++;
-} while(bitoffset<maxbitoffset);
-
-}       /* End the big while(nloops--) from above */
-
-
+            textoffset++;
+        } while ( bitoffset < maxbitoffset );
 
+    } /* End the big while(nloops--) from above */
 }
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
Only in sgx-nbench/Enclave: Enclave.cpp~
Only in sgx-nbench/Enclave: Enclave.cpp.orig
diff --color -ur sgx-nbench/Enclave/Enclave.edl sgx-nbench1/Enclave/Enclave.edl
--- sgx-nbench/Enclave/Enclave.edl	2022-05-02 18:22:14.583889634 +0200
+++ sgx-nbench1/Enclave/Enclave.edl	2022-05-02 16:32:45.727526000 +0200
@@ -2,7 +2,7 @@
 
 enclave {
     
-    include "user_types.h" /* buffer_t */
+    //include "user_types.h" /* buffer_t */
 
     trusted {
         public void test_function([in,string] const char *str);
Only in sgx-nbench/Enclave: Enclave.edl~
Only in sgx-nbench/Enclave: Enclave.edl.orig
Only in sgx-nbench1/Enclave: Enclave_gs.config.xml
Only in sgx-nbench/Enclave: Enclave.h~
Only in sgx-nbench/Enclave: Enclave_private.pem
diff --color -ur sgx-nbench/Enclave/encl_emfloat.c sgx-nbench1/Enclave/encl_emfloat.c
--- sgx-nbench/Enclave/encl_emfloat.c	2022-05-02 18:22:14.583889634 +0200
+++ sgx-nbench1/Enclave/encl_emfloat.c	2022-05-02 16:32:45.727526000 +0200
@@ -65,6 +65,7 @@
                 InternalFPF *cbase,*/
                 ulong arraysize)
 {
+        ocall_print_string("here!");
 ulong i;
 InternalFPF locFPF1,locFPF2;
 InternalFPF *abase = enclave_buffer;
@@ -101,6 +102,7 @@
                 InternalFPF *cbase,*/
                 ulong arraysize, ulong loops)
 {
+        
 ulong elapsed;          /* For the stopwatch */
 static uchar jtable[16] = {0,0,0,0,1,1,1,1,2,2,2,2,2,3,3,3};
 ulong i;
Only in sgx-nbench: .git
diff --color -ur sgx-nbench/Makefile sgx-nbench1/Makefile
--- sgx-nbench/Makefile	2022-05-02 18:22:14.583889634 +0200
+++ sgx-nbench1/Makefile	2022-05-02 16:32:45.727526000 +0200
@@ -1,10 +1,17 @@
 ######## SGX SDK Settings ########
 
+NBENCHDIR = nbenchPortal/
+
+TR_CC ?= ../../../../linux-sgx/compiler
+TR_CXX ?= ../../../../linux-sgx/compiler++
+
 SGX_SDK ?= /opt/intel/sgxsdk
-SGX_ARCH ?= x64
 SGX_MODE ?= HW
+SGX_ARCH ?= x64
+SGX_DEBUG ?= 0
 SGX_PRERELEASE ?= 1
-NBENCHDIR = nbenchPortal/
+
+include $(SGX_SDK)/buildenv.mk
 
 ifeq ($(shell getconf LONG_BIT), 32)
 	SGX_ARCH := x86
@@ -12,13 +19,14 @@
 	SGX_ARCH := x86
 endif
 
+
 ifeq ($(SGX_ARCH), x86)
-	SGX_COMMON_CFLAGS := -m32
+	SGX_COMMON_FLAGS := -m32
 	SGX_LIBRARY_PATH := $(SGX_SDK)/lib
 	SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x86/sgx_sign
 	SGX_EDGER8R := $(SGX_SDK)/bin/x86/sgx_edger8r
 else
-	SGX_COMMON_CFLAGS := -m64
+	SGX_COMMON_FLAGS := -m64
 	SGX_LIBRARY_PATH := $(SGX_SDK)/lib64
 	SGX_ENCLAVE_SIGNER := $(SGX_SDK)/bin/x64/sgx_sign
 	SGX_EDGER8R := $(SGX_SDK)/bin/x64/sgx_edger8r
@@ -31,11 +39,20 @@
 endif
 
 ifeq ($(SGX_DEBUG), 1)
-        SGX_COMMON_CFLAGS += -O0 -g
+$(error Cannot set SGX_DEBUG and SGX_PRERELEASE at the same time!!)
 else
-        SGX_COMMON_CFLAGS += -O2
+        SGX_COMMON_FLAGS += -O3 -fno-builtin
 endif
 
+#
+
+SGX_COMMON_FLAGS += -Wall -Wextra -Winit-self -Wpointer-arith -Wreturn-type \
+                    -Waddress -Wsequence-point -Wformat-security \
+                    -Wmissing-include-dirs -Wfloat-equal -Wundef -Wshadow \
+                    -Wcast-align -Wcast-qual -Wconversion -Wredundant-decls
+SGX_COMMON_CFLAGS := $(SGX_COMMON_FLAGS) -Wstrict-prototypes -Wunsuffixed-float-constants #-Wjump-misses-init 
+SGX_COMMON_CXXFLAGS := $(SGX_COMMON_FLAGS) -Wnon-virtual-dtor -std=c++11
+
 ######## App Settings ########
 
 ifneq ($(SGX_MODE), HW)
@@ -44,12 +61,10 @@
 	Urts_Library_Name := sgx_urts
 endif
 
-App_Cpp_Files := App/App.cpp $(wildcard App/Edger8rSyntax/*.cpp) $(wildcard App/TrustedLibrary/*.cpp)
-App_Include_Paths := -IInclude -IApp -I$(SGX_SDK)/include -InbenchPortal
+App_Cpp_Files := App/App.cpp
+App_Include_Paths := -IApp -I$(SGX_SDK)/include
 
-App_C_Files := $(wildcard nbenchPortal/*.c)
-
-App_C_Flags := $(SGX_COMMON_CFLAGS) -fPIC -Wno-attributes $(App_Include_Paths)
+App_C_Flags := -fPIC -Wno-attributes $(App_Include_Paths) -g
 
 # Three configuration modes - Debug, prerelease, release
 #   Debug - Macro DEBUG enabled.
@@ -63,72 +78,120 @@
         App_C_Flags += -DNDEBUG -UEDEBUG -UDEBUG
 endif
 
-App_Cpp_Flags := $(App_C_Flags) -std=c++11
-App_Link_Flags := $(SGX_COMMON_CFLAGS) -L$(SGX_LIBRARY_PATH) -l$(Urts_Library_Name) -lpthread 
-
-ifneq ($(SGX_MODE), HW)
-	App_Link_Flags += -lsgx_uae_service_sim
-else
-	App_Link_Flags += -lsgx_uae_service
-endif
+App_Cpp_Flags := $(App_C_Flags)
+App_Link_Flags := -L$(SGX_LIBRARY_PATH) -l$(Urts_Library_Name) -lpthread 
 
 App_Cpp_Objects := $(App_Cpp_Files:.cpp=.o)
-App_C_Objects := $(App_C_Files:.c=.o)
-App_Name := app
+
+App_Name := main
 
 ######## Enclave Settings ########
 
 ifneq ($(SGX_MODE), HW)
 	Trts_Library_Name := sgx_trts_sim
 	Service_Library_Name := sgx_tservice_sim
-	Crypto_Library_Name := sgx_tcrypto
 else
 	Trts_Library_Name := sgx_trts
 	Service_Library_Name := sgx_tservice
-	Crypto_Library_Name := sgx_tcrypto
+endif
+Crypto_Library_Name := sgx_tcrypto
+
+Enclave_Cpp_Files := Enclave/Enclave.cpp
+Enclave_Include_Paths := -IEnclave -I$(SGX_SDK)/include -I$(SGX_SDK)/include/tlibc -I$(SGX_SDK)/include/libcxx -I$(NBENCHDIR)
+
+Enclave_C_Flags := $(Enclave_Include_Paths) -nostdinc -fvisibility=hidden  -fno-pic -fno-pie  -ffunction-sections -fdata-sections $(MITIGATION_CFLAGS) 
+CC_BELOW_4_9 := $(shell expr "`$(CC) -dumpversion`" \< "4.9")
+ifeq ($(CC_BELOW_4_9), 1)
+	Enclave_C_Flags += -fstack-protector
+else
+	Enclave_C_Flags += -fstack-protector-strong
 endif
 
-Enclave_Cpp_Files := Enclave/Enclave.cpp $(wildcard Enclave/Edger8rSyntax/*.cpp) $(wildcard Enclave/TrustedLibrary/*.cpp)
-Enclave_Include_Paths := -IInclude -IEnclave -I$(SGX_SDK)/include -I$(SGX_SDK)/include/tlibc -I$(SGX_SDK)/include/stlport -I$(NBENCHDIR)
 
-Enclave_C_Flags := $(SGX_COMMON_CFLAGS) -nostdinc -fvisibility=hidden -fpie -fstack-protector $(Enclave_Include_Paths)
-Enclave_Cpp_Flags := $(Enclave_C_Flags) -std=c++03 -nostdinc++
-Enclave_Link_Flags := $(SGX_COMMON_CFLAGS) -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L$(SGX_LIBRARY_PATH) \
+Enclave_Cpp_Flags := $(Enclave_C_Flags) -nostdinc++
+
+# Enable the security flags
+Enclave_Security_Link_Flags := -Wl,-z,relro,-z,now,-z,noexecstack
+
+# To generate a proper Enclave, it is recommended to follow below guideline to link the trusted libraries:
+#    1. Link sgx_trts with the `--whole-archive' and `--no-whole-archive' options,
+#       so that the whole content of trts is included in the Enclave.
+#    2. For other libraries, you just need to pull the required symbols.
+#       Use `--start-group' and `--end-group' to link these libraries.
+# Do NOT move the libraries linked with `--start-group' and `--end-group' within `--whole-archive' and `--no-whole-archive' options.
+# Otherwise, you may get some undesirable errors.
+Enclave_Link_Flags := $(MITIGATION_LDFLAGS) $(Enclave_Security_Link_Flags) \
+    -Wl,--no-undefined -nostdlib -nodefaultlibs -nostartfiles -L$(SGX_TRUSTED_LIBRARY_PATH) \
 	-Wl,--whole-archive -l$(Trts_Library_Name) -Wl,--no-whole-archive \
-	-Wl,--start-group -lsgx_tstdc -lsgx_tstdcxx -l$(Crypto_Library_Name) -l$(Service_Library_Name) -Wl,--end-group \
+	-Wl,--start-group -lsgx_tstdc -lsgx_tcxx -l$(Crypto_Library_Name) -l$(Service_Library_Name) -Wl,--end-group \
 	-Wl,-Bstatic -Wl,-Bsymbolic -Wl,--no-undefined \
 	-Wl,-pie,-eenclave_entry -Wl,--export-dynamic  \
-	-Wl,--defsym,__ImageBase=0 \
+	-Wl,--defsym,__ImageBase=0 -Wl,--gc-sections \
 	-Wl,--version-script=Enclave/Enclave.lds
 
-Enclave_Cpp_Objects := $(Enclave_Cpp_Files:.cpp=.o)
+Enclave_Cpp_Objects := $(sort $(Enclave_Cpp_Files:.cpp=.o)) Enclave/encl_emfloat.o
+
+Enclave_Name := Enclave.so
+Signed_Enclave_Name := Enclave.signed.so
+
 
-Enclave_Name := enclave.so
-Signed_Enclave_Name := enclave.signed.so
 Enclave_Config_File := Enclave/Enclave.config.xml
+Enclave_C_Flags += -fpic
+Enclave_Cpp_Flags += -fpic
+
 
 ifeq ($(SGX_MODE), HW)
-ifneq ($(SGX_DEBUG), 1)
-ifneq ($(SGX_PRERELEASE), 1)
-Build_Mode = HW_RELEASE
+ifeq ($(SGX_DEBUG), 1)
+	Build_Mode = HW_DEBUG
+else ifeq ($(SGX_PRERELEASE), 1)
+	Build_Mode = HW_PRERELEASE
+else
+	Build_Mode = HW_RELEASE
 endif
+else
+ifeq ($(SGX_DEBUG), 1)
+	Build_Mode = SIM_DEBUG
+else ifeq ($(SGX_PRERELEASE), 1)
+	Build_Mode = SIM_PRERELEASE
+else
+	Build_Mode = SIM_RELEASE
 endif
 endif
 
+.SILENT:
+
+.PHONY: all target run
+all: .config_$(Build_Mode)_$(SGX_ARCH)
+	@$(MAKE) target
+
 
-.PHONY: all run
+debug: all
+	/opt/intel/sgxsdk/bin/sgx-gdb ./main
 
 ifeq ($(Build_Mode), HW_RELEASE)
-all: $(App_Name) $(Enclave_Name)
+target:  $(App_Name) $(Enclave_Name)
 	@echo "The project has been built in release hardware mode."
-	@echo "Please sign the $(Enclave_Name) first with your signing key before you run the $(App_Name) to launch and access the enclave."
-	@echo "To sign the enclave use the command:"
+	@echo "Please sign the $(Enclave_Name) first with your signing key before you run the $(App_Name) to launch and access the Enclave."
+	@echo "To sign the Enclave use the command:"
 	@echo "   $(SGX_ENCLAVE_SIGNER) sign -key <your key> -enclave $(Enclave_Name) -out <$(Signed_Enclave_Name)> -config $(Enclave_Config_File)"
-	@echo "You can also sign the enclave using an external signing tool. See User's Guide for more details."
+	@echo "You can also sign the enclave using an external signing tool."
 	@echo "To build the project in simulation mode set SGX_MODE=SIM. To build the project in prerelease mode set SGX_PRERELEASE=1 and SGX_MODE=HW."
+
+else
+target: $(App_Name) $(Signed_Enclave_Name)
+ifeq ($(Build_Mode), HW_DEBUG)
+	@echo "The project has been built in debug hardware mode."
+else ifeq ($(Build_Mode), SIM_DEBUG)
+	@echo "The project has been built in debug simulation mode."
+else ifeq ($(Build_Mode), HW_PRERELEASE)
+	@echo "The project has been built in pre-release hardware mode."
+else ifeq ($(Build_Mode), SIM_PRERELEASE)
+	@echo "The project has been built in pre-release simulation mode."
 else
-all: $(App_Name) $(Signed_Enclave_Name)
+	@echo "The project has been built in release simulation mode."
 endif
+endif
+	
 
 run: all
 ifneq ($(Build_Mode), HW_RELEASE)
@@ -136,18 +199,24 @@
 	@echo "RUN  =>  $(App_Name) [$(SGX_MODE)|$(SGX_ARCH), OK]"
 endif
 
+.config_$(Build_Mode)_$(SGX_ARCH):
+	@rm -f .config_* App/$(App_Name) $(Enclave_Name) $(Signed_Enclave_Name) $(App_Cpp_Objects) App/Enclave_u.* $(Enclave_Cpp_Objects) Enclave/Enclave_t.*
+	@touch .config_$(Build_Mode)_$(SGX_ARCH)
+
 ######## App Objects ########
 
-App/Enclave_u.c: $(SGX_EDGER8R) Enclave/Enclave.edl
+App/Enclave_u.h: $(SGX_EDGER8R) Enclave/Enclave.edl
 	@cd App && $(SGX_EDGER8R) --untrusted ../Enclave/Enclave.edl --search-path ../Enclave --search-path $(SGX_SDK)/include
 	@echo "GEN  =>  $@"
 
+App/Enclave_u.c: App/Enclave_u.h
+
 App/Enclave_u.o: App/Enclave_u.c
-	@$(CC) $(App_C_Flags) -c $< -o $@
+	@$(CC) $(SGX_COMMON_CFLAGS) $(App_C_Flags) -c $< -o $@
 	@echo "CC   <=  $<"
 
-App/%.o: App/%.cpp
-	@$(CXX) $(App_Cpp_Flags) -c $< -o $@
+App/%.o: App/%.cpp  App/Enclave_u.h
+	@$(CXX) $(SGX_COMMON_CXXFLAGS) $(App_Cpp_Flags) -c $< -o $@
 	@echo "CXX  <=  $<"
 
 $(App_Name): App/Enclave_u.o $(App_Cpp_Objects) 	
@@ -160,32 +229,44 @@
 
 ######## Enclave Objects ########
 
-Enclave/Enclave_t.c: $(SGX_EDGER8R) Enclave/Enclave.edl
+Enclave/Enclave_t.h: $(SGX_EDGER8R) Enclave/Enclave.edl
 	@cd Enclave && $(SGX_EDGER8R) --trusted ../Enclave/Enclave.edl --search-path ../Enclave --search-path $(SGX_SDK)/include
 	@echo "GEN  =>  $@"
 
-Enclave/Enclave_t.o: Enclave/Enclave_t.c 
-	@$(CC) $(Enclave_C_Flags) -c $< -o $@
+Enclave/Enclave_t.c: Enclave/Enclave_t.h
+
+Enclave/Enclave_t.o: Enclave/Enclave_t.c
+	@$(TR_CC) $(SGX_COMMON_CFLAGS) $(Enclave_C_Flags) -c $< -o $@
 	@echo "CC   <=  $<"
 
-Enclave/%.o: Enclave/%.cpp
-	@$(CXX) $(Enclave_Cpp_Flags) -c $< -o $@
+Enclave/%.o: Enclave/%.cpp Enclave/Enclave_t.h
+	echo $(SGX_COMMON_CXXFLAGS) $(Enclave_Cpp_Flags)
+	@$(TR_CXX) $(SGX_COMMON_CXXFLAGS) $(Enclave_Cpp_Flags) -c $< -o $@
 	@echo "CXX  <=  $<"
 
-Enclave/encl_emfloat.o:
-	@$(CC) $(Enclave_C_Flags) $(Enclave_include_paths) Enclave/encl_emfloat.c -c -o $@
+Enclave/encl_emfloat.o: Enclave/encl_emfloat.c
+	@$(TR_CC) $(SGX_COMMON_CFLAGS) $(Enclave_C_Flags) -c $< -o $@
+	@echo "C  <=  $<"
+	
+$(Enclave_Name): Enclave/Enclave_t.o $(Enclave_Cpp_Objects)
+
+	@$(TR_CXX) Enclave/Enclave_t.o $(Enclave_Cpp_Objects) -o $@ $(MITIGATION_LDFLAGS) $(Enclave_Security_Link_Flags) $(Enclave_Link_Flags)
+
+#adapt_relocations: $(TRTS_OBJS_MOD) $(TSTDC_OBJS_MOD) $(TSERVICE_OBJS)#
+#	ar rcs libsgx_trts_mod.a $(TRTS_OBJS_MOD)
+#	ar rcs libsgx_tstdc_mod.a $(TSTDC_OBJS_MOD)
+#	ar rcs libsgx_tservice_mod.a $(TSERVICE_OBJS)
 
-$(Enclave_Name): Enclave/encl_emfloat.o Enclave/Enclave_t.o Enclave/encl_emfloat.o $(Enclave_Cpp_Objects) 
-	@$(CXX) $^ -o $@ $(Enclave_Link_Flags)
-	@echo "LINK =>  $@"
 
 $(Signed_Enclave_Name): $(Enclave_Name)
-	@$(SGX_ENCLAVE_SIGNER) sign -key Enclave/Enclave_private.pem -enclave $(Enclave_Name) -out $@ -config $(Enclave_Config_File)
+	@openssl genrsa -out Enclave/private.pem -3 3072
+	@openssl rsa -in Enclave/private.pem -pubout -out Enclave/public.pem
+	@$(SGX_ENCLAVE_SIGNER) sign -ignore-rel-error -key Enclave/private.pem -enclave $(Enclave_Name) -out $@ -config  $(Enclave_Config_File)
 	@echo "SIGN =>  $@"
 
 .PHONY: clean
 
 clean:
-	$(MAKE) -C $(NBENCHDIR) clean
-	@rm -f $(App_Name) $(Enclave_Name) $(Signed_Enclave_Name) $(App_Cpp_Objects) App/Enclave_u.* $(Enclave_Cpp_Objects) Enclave/Enclave_t.* $(NBENCHDIR)*.o $(NBENCHDIR)*~ Enclave/*.o 
 
+	@rm -f .config_* $(App_Name) $(Enclave_Name) $(Signed_Enclave_Name) $(App_Cpp_Objects) App/Enclave_u.* $(Enclave_Cpp_Objects) Enclave/Enclave_t.* monolith.o
+	@rm -rf tmp_obj
diff --color -ur sgx-nbench/nbenchPortal/emfloat.h sgx-nbench1/nbenchPortal/emfloat.h
--- sgx-nbench/nbenchPortal/emfloat.h	2022-05-02 18:22:14.587889680 +0200
+++ sgx-nbench1/nbenchPortal/emfloat.h	2022-05-02 16:32:45.727526000 +0200
@@ -34,10 +34,13 @@
 /*
 ** DEFINES
 */
+
 #define u8 unsigned char
 #define u16 unsigned short
 #ifdef LONG64
 #define u32 unsigned int
+#define int32 int
+
 #else
 #define u32 unsigned long
 #endif
@@ -92,9 +95,9 @@
 /*
 ** Following already defined in NMGLOBAL.H
 **
-#define INTERNAL_FPF_PRECISION 4
+define INTERNAL_FPF_PRECISION 4
 */
-
+#define INTERNAL_FPF_PRECISION 4
 /*
 ** TYPEDEFS
 */
Binary files sgx-nbench/nbenchPortal/gmon.out and sgx-nbench1/nbenchPortal/gmon.out differ
diff --color -ur sgx-nbench/nbenchPortal/nbench0.c sgx-nbench1/nbenchPortal/nbench0.c
--- sgx-nbench/nbenchPortal/nbench0.c	2022-05-02 18:22:14.587889680 +0200
+++ sgx-nbench1/nbenchPortal/nbench0.c	2022-05-02 16:32:45.731526000 +0200
@@ -64,300 +64,304 @@
 int mainn(int argc, char *argv[])
 #endif
 {
-int i;                  /* Index */
-time_t time_and_date;   /* Self-explanatory */
-struct tm *loctime;
-double bmean;           /* Benchmark mean */
-double bstdev;          /* Benchmark stdev */
-double lx_memindex;     /* Linux memory index (mainly integer operations)*/
-double lx_intindex;     /* Linux integer index */
-double lx_fpindex;      /* Linux floating-point index */
-double intindex;        /* Integer index */
-double fpindex;         /* Floating-point index */
-ulong bnumrun;          /* # of runs */
-
-#ifdef MAC
-        MaxApplZone();
-#endif
+        int i;                  /* Index */
+        time_t time_and_date;   /* Self-explanatory */
+        struct tm *loctime;
+        double bmean;           /* Benchmark mean */
+        double bstdev;          /* Benchmark stdev */
+        double lx_memindex;     /* Linux memory index (mainly integer operations)*/
+        double lx_intindex;     /* Linux integer index */
+        double lx_fpindex;      /* Linux floating-point index */
+        double intindex;        /* Integer index */
+        double fpindex;         /* Floating-point index */
+        ulong bnumrun;          /* # of runs */
+
+        #ifdef MAC
+                MaxApplZone();
+        #endif
+
+        #ifdef MACTIMEMGR
+        /* Set up high res timer */
+        MacHSTdelay=600*1000*1000;      /* Delay is 10 minutes */
+
+        memset((char *)&myTMTask,0,sizeof(TMTask));
+
+        /* Prime and remove the task, calculating overhead */
+        PrimeTime((QElemPtr)&myTMTask,-MacHSTdelay);
+        RmvTime((QElemPtr)&myTMTask);
+        MacHSTohead=MacHSTdelay+myTMTask.tmCount;
+        #endif
+
+        #ifdef WIN31TIMER
+        /* Set up the size of the timer info structure */
+        win31tinfo.dwSize=(DWORD)sizeof(TIMERINFO);
+        /* Load library */
+        if((hThlp=LoadLibrary("TOOLHELP.DLL"))<32)
+        {       printf("Error loading TOOLHELP\n");
+                exit(0);
+        }
+        if(!(lpfn=GetProcAddress(hThlp,"TimerCount")))
+        {       printf("TOOLHELP error\n");
+                exit(0);
+        }
+        #endif
 
-#ifdef MACTIMEMGR
-/* Set up high res timer */
-MacHSTdelay=600*1000*1000;      /* Delay is 10 minutes */
-
-memset((char *)&myTMTask,0,sizeof(TMTask));
-
-/* Prime and remove the task, calculating overhead */
-PrimeTime((QElemPtr)&myTMTask,-MacHSTdelay);
-RmvTime((QElemPtr)&myTMTask);
-MacHSTohead=MacHSTdelay+myTMTask.tmCount;
-#endif
+        /*
+        ** Set global parameters to default.
+        */
+        global_min_ticks=MINIMUM_TICKS;
+        global_min_seconds=MINIMUM_SECONDS;
+        global_allstats=0;
+        global_custrun=0;
+        global_align=8;
+        write_to_file=0;
+        lx_memindex=(double)1.0;        /* set for geometric mean computations */
+        lx_intindex=(double)1.0;
+        lx_fpindex=(double)1.0;
+        intindex=(double)1.0;
+        fpindex=(double)1.0;
+        mem_array_ents=0;               /* Nothing in mem array */
 
-#ifdef WIN31TIMER
-/* Set up the size of the timer info structure */
-win31tinfo.dwSize=(DWORD)sizeof(TIMERINFO);
-/* Load library */
-if((hThlp=LoadLibrary("TOOLHELP.DLL"))<32)
-{       printf("Error loading TOOLHELP\n");
-        exit(0);
-}
-if(!(lpfn=GetProcAddress(hThlp,"TimerCount")))
-{       printf("TOOLHELP error\n");
-        exit(0);
-}
-#endif
+        /*
+        ** We presume all tests will be run unless told
+        ** otherwise
+        */
 
-/*
-** Set global parameters to default.
-*/
-global_min_ticks=MINIMUM_TICKS;
-global_min_seconds=MINIMUM_SECONDS;
-global_allstats=0;
-global_custrun=0;
-global_align=8;
-write_to_file=0;
-lx_memindex=(double)1.0;        /* set for geometric mean computations */
-lx_intindex=(double)1.0;
-lx_fpindex=(double)1.0;
-intindex=(double)1.0;
-fpindex=(double)1.0;
-mem_array_ents=0;               /* Nothing in mem array */
+        //NUMTESTS=10
+        //tests_to_do = INTEGER ARRAY FILLED WITH 1
+        int passed_num = 0;
+
+        if(argc <= 1 || atoi(argv[1]) <= 0 || atoi(argv[1]) > 10){
+        for(i=0;i<NUMTESTS;i++)
+                tests_to_do[i]=1;
+                
+        }else{
+        tests_to_do[atoi(argv[1])-1]=1;
+        passed_num = 1;
+        }
 
-/*
-** We presume all tests will be run unless told
-** otherwise
-*/
+        /*
+        ** Initialize test data structures to default
+        ** values.
+        */
+        set_request_secs();     /* Set all request_secs fields */
+        global_numsortstruct.adjust=0;
+        global_numsortstruct.arraysize=NUMARRAYSIZE;
 
-//NUMTESTS=10
-//tests_to_do = INTEGER ARRAY FILLED WITH 1
-int passed_num = 0;
-
-if(argc <= 1 || atoi(argv[1]) <= 0 || atoi(argv[1]) > 10){
-    for(i=0;i<NUMTESTS;i++)
-	tests_to_do[i]=1;
-	
-}else{
-    tests_to_do[atoi(argv[1])-1]=1;
-    passed_num = 1;
-}
+        global_strsortstruct.adjust=0;
+        global_strsortstruct.arraysize=STRINGARRAYSIZE;
 
-/*
-** Initialize test data structures to default
-** values.
-*/
-set_request_secs();     /* Set all request_secs fields */
-global_numsortstruct.adjust=0;
-global_numsortstruct.arraysize=NUMARRAYSIZE;
+        global_bitopstruct.adjust=0;
+        global_bitopstruct.bitfieldarraysize=BITFARRAYSIZE;
 
-global_strsortstruct.adjust=0;
-global_strsortstruct.arraysize=STRINGARRAYSIZE;
+        global_emfloatstruct.adjust=0;
+        global_emfloatstruct.arraysize=EMFARRAYSIZE;
 
-global_bitopstruct.adjust=0;
-global_bitopstruct.bitfieldarraysize=BITFARRAYSIZE;
+        global_fourierstruct.adjust=0;
 
-global_emfloatstruct.adjust=0;
-global_emfloatstruct.arraysize=EMFARRAYSIZE;
+        global_assignstruct.adjust=0;
 
-global_fourierstruct.adjust=0;
+        global_ideastruct.adjust=0;
+        global_ideastruct.arraysize=IDEAARRAYSIZE;
 
-global_assignstruct.adjust=0;
+        global_huffstruct.adjust=0;
+        global_huffstruct.arraysize=HUFFARRAYSIZE;
 
-global_ideastruct.adjust=0;
-global_ideastruct.arraysize=IDEAARRAYSIZE;
+        global_nnetstruct.adjust=0;
 
-global_huffstruct.adjust=0;
-global_huffstruct.arraysize=HUFFARRAYSIZE;
+        global_lustruct.adjust=0;
 
-global_nnetstruct.adjust=0;
+        /*
+        ** For Macintosh -- read the command line.
+        */
+        #ifdef MAC
+        UCommandLine();
+        #endif
 
-global_lustruct.adjust=0;
+        /*
+        ** Handle any command-line arguments.
+        */
+        if(argc>1)
+                for(i=1+passed_num;i<argc;i++)
+                        if(parse_arg(argv[i])==-1)
+                        {       display_help(argv[0]);
+                                exit(0);
+                        }
 
-/*
-** For Macintosh -- read the command line.
-*/
-#ifdef MAC
-UCommandLine();
-#endif
+        /*
+        ** Output header
+        */
 
-/*
-** Handle any command-line arguments.
-*/
-if(argc>1)
-        for(i=1+passed_num;i<argc;i++)
-                if(parse_arg(argv[i])==-1)
-                {       display_help(argv[0]);
-                        exit(0);
-                }
+        //EXECUTES
+        #ifdef LINUX
+        //output_string("\nBYTEmark* Native Mode Benchmark ver. 2 (10/95)\n");
+        //output_string("Index-split by Andrew D. Balsa (11/97)\n");
+        //output_string("Linux/Unix* port by Uwe F. Mayer (12/96,11/97)\n");
+        output_string("====================Modified version of nbench for Intel SGX==========================");
+        #else
+        //DOES NOT EXECUTE
+        output_string("BBBBBB   YYY   Y  TTTTTTT  EEEEEEE\n");
+        output_string("BBB   B  YYY   Y    TTT    EEE\n");
+        output_string("BBB   B  YYY   Y    TTT    EEE\n");
+        output_string("BBBBBB    YYY Y     TTT    EEEEEEE\n");
+        output_string("BBB   B    YYY      TTT    EEE\n");
+        output_string("BBB   B    YYY      TTT    EEE\n");
+        output_string("BBBBBB     YYY      TTT    EEEEEEE\n\n");
+        output_string("\nBYTEmark (tm) Native Mode Benchmark ver. 2 (10/95)\n");
+        #endif
+        /*
+        ** See if the user wants all stats.  Output heading info
+        ** if so.
+        */
 
-/*
-** Output header
-*/
+        //DO NOT EXECUTE
+        if(global_allstats)
+        {
+                        output_string("\n");
+                        output_string("============================== ALL STATISTICS ===============================\n");
+                time(&time_and_date);
+                loctime=localtime(&time_and_date);
+                sprintf(buffer,"**Date and time of benchmark run: %s",asctime(loctime));
+                output_string(buffer);
+                sprintf(buffer,"**Sizeof: char:%u short:%u int:%u long:%u u8:%u u16:%u u32:%u int32:%u\n",
+                        (unsigned int)sizeof(char),
+                        (unsigned int)sizeof(short),
+                        (unsigned int)sizeof(int),
+                        (unsigned int)sizeof(long),
+                        (unsigned int)sizeof(u8),
+                        (unsigned int)sizeof(u16),
+                        (unsigned int)sizeof(u32),
+                        (unsigned int)sizeof(int32));
+                output_string(buffer);
+        #ifdef LINUX
+        #include "sysinfo.c"
+        #else
+                sprintf(buffer,"**%s\n",sysname);
+                output_string(buffer);
+                sprintf(buffer,"**%s\n",compilername);
+                output_string(buffer);
+                sprintf(buffer,"**%s\n",compilerversion);
+                output_string(buffer);
+        #endif
+                        output_string("=============================================================================\n");
+        }
 
-//EXECUTES
-#ifdef LINUX
-//output_string("\nBYTEmark* Native Mode Benchmark ver. 2 (10/95)\n");
-//output_string("Index-split by Andrew D. Balsa (11/97)\n");
-//output_string("Linux/Unix* port by Uwe F. Mayer (12/96,11/97)\n");
-output_string("====================Modified version of nbench for Intel SGX====================");
-#else
-//DOES NOT EXECUTE
-output_string("BBBBBB   YYY   Y  TTTTTTT  EEEEEEE\n");
-output_string("BBB   B  YYY   Y    TTT    EEE\n");
-output_string("BBB   B  YYY   Y    TTT    EEE\n");
-output_string("BBBBBB    YYY Y     TTT    EEEEEEE\n");
-output_string("BBB   B    YYY      TTT    EEE\n");
-output_string("BBB   B    YYY      TTT    EEE\n");
-output_string("BBBBBB     YYY      TTT    EEEEEEE\n\n");
-output_string("\nBYTEmark (tm) Native Mode Benchmark ver. 2 (10/95)\n");
-#endif
-/*
-** See if the user wants all stats.  Output heading info
-** if so.
-*/
 
-//DO NOT EXECUTE
-if(global_allstats)
-{
-                output_string("\n");
-                output_string("============================== ALL STATISTICS ===============================\n");
-        time(&time_and_date);
-        loctime=localtime(&time_and_date);
-        sprintf(buffer,"**Date and time of benchmark run: %s",asctime(loctime));
-        output_string(buffer);
-        sprintf(buffer,"**Sizeof: char:%u short:%u int:%u long:%u u8:%u u16:%u u32:%u int32:%u\n",
-                (unsigned int)sizeof(char),
-                (unsigned int)sizeof(short),
-                (unsigned int)sizeof(int),
-                (unsigned int)sizeof(long),
-                (unsigned int)sizeof(u8),
-                (unsigned int)sizeof(u16),
-                (unsigned int)sizeof(u32),
-                (unsigned int)sizeof(int32));
-        output_string(buffer);
-#ifdef LINUX
-#include "sysinfo.c"
-#else
-        sprintf(buffer,"**%s\n",sysname);
-        output_string(buffer);
-        sprintf(buffer,"**%s\n",compilername);
-        output_string(buffer);
-        sprintf(buffer,"**%s\n",compilerversion);
-        output_string(buffer);
-#endif
-                output_string("=============================================================================\n");
-}
+        //EXECUTES
+        /*
+        ** Execute the tests.
+        */
+        #ifdef LINUX
+        output_string("\n");
+        output_string("TEST                : mean iter/sec.   : stdev            : stderr           : nruns :\n");
+        output_string("--------------------:------------------:------------------:------------------:-------:\n");
+        #endif
 
+        //NUMTESTS=10
+        for(i=0;i<NUMTESTS;i++)
+        {
+                //EVALUATES TRUE 10 TIMES
+                if(tests_to_do[i])
+                {       sprintf(buffer,"%s    :",ftestnames[i]);
+                                        output_string(buffer);
+                        //output_string("EXECUTES HERE");
+                                //DOES NOT EXECUTE                
+                                if (0!=bench_with_confidence(i,
+                                &bmean,
+                                &bstdev,
+                                &bnumrun)){
+                        output_string("\n** WARNING: The current test result is NOT 99 % statistically certain.\n");
+                        output_string("** WARNING: The variation among the individual results is too large.\n");
+                        output_string("                    :");
+                        }
 
-//EXECUTES
-/*
-** Execute the tests.
-*/
-#ifdef LINUX
-output_string("\nTEST                : Iterations/sec.  : Old Index   : New Index\n");
-output_string("                    :                  : Pentium 90* : AMD K6/233*\n");
-output_string("--------------------:------------------:-------------:------------\n");
-#endif
+                        sprintf(buffer," %15.5f  : %15.5f  : %15.5f  :  %3.lu  : \n", bmean, bstdev, bstdev/sqrt((double)bnumrun), bnumrun);
+        /*                
+        #ifdef LINUX
+                        sprintf(buffer," %15.5g  :  %9.2f  :  %9.2f\n",
+                                bmean,bmean/bindex[i],bmean/lx_bindex[i]);
+        #else
+                        sprintf(buffer,"  Iterations/sec.: %13.2f  Index: %6.2f\n",
+                                bmean,bmean/bindex[i]);
+        #endif
+        */
+                        output_string(buffer);
+                        /*
+                        ** Gather integer or FP indexes
+                        */
+                        if((i==4)||(i==8)||(i==9)){
+                        /* FP index */
+                        fpindex=fpindex*(bmean/bindex[i]);
+                        /* Linux FP index */
+                        lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
+                        }
+                        else{
+                        /* Integer index */
+                        intindex=intindex*(bmean/bindex[i]);
+                        if((i==0)||(i==3)||(i==6)||(i==7))
+                        /* Linux integer index */
+                        lx_intindex=lx_intindex*(bmean/lx_bindex[i]);
+                        else
+                        /* Linux memory index */
+                        lx_memindex=lx_memindex*(bmean/lx_bindex[i]);
+                        }
 
-//NUMTESTS=10
-for(i=0;i<NUMTESTS;i++)
-{
-	//EVALUATES TRUE 10 TIMES
-        if(tests_to_do[i])
-        {       sprintf(buffer,"%s    :",ftestnames[i]);
+                        if(global_allstats)
+                        {
+                                sprintf(buffer,"  Absolute standard deviation: %g\n",bstdev);
                                 output_string(buffer);
-		//output_string("EXECUTES HERE");
-			//DOES NOT EXECUTE                
-			if (0!=bench_with_confidence(i,
-                        &bmean,
-                        &bstdev,
-                        &bnumrun)){
-		  output_string("\n** WARNING: The current test result is NOT 99 % statistically certain.\n");
-		  output_string("** WARNING: The variation among the individual results is too large.\n");
-		  output_string("                    :");
-		}
-#ifdef LINUX
-                sprintf(buffer," %15.5g  :  %9.2f  :  %9.2f\n",
-                        bmean,bmean/bindex[i],bmean/lx_bindex[i]);
-#else
-		sprintf(buffer,"  Iterations/sec.: %13.2f  Index: %6.2f\n",
-                        bmean,bmean/bindex[i]);
-#endif
-                output_string(buffer);
-		/*
-		** Gather integer or FP indexes
-		*/
-		if((i==4)||(i==8)||(i==9)){
-		  /* FP index */
-		  fpindex=fpindex*(bmean/bindex[i]);
-		  /* Linux FP index */
-		  lx_fpindex=lx_fpindex*(bmean/lx_bindex[i]);
-		}
-		else{
-		  /* Integer index */
-		  intindex=intindex*(bmean/bindex[i]);
-		  if((i==0)||(i==3)||(i==6)||(i==7))
-		    /* Linux integer index */
-		    lx_intindex=lx_intindex*(bmean/lx_bindex[i]);
-		  else
-		    /* Linux memory index */
-		    lx_memindex=lx_memindex*(bmean/lx_bindex[i]);
-		}
-
-                if(global_allstats)
-                {
-                        sprintf(buffer,"  Absolute standard deviation: %g\n",bstdev);
-                        output_string(buffer);
-			if (bmean>(double)1e-100){
-			  /* avoid division by zero */
-			  sprintf(buffer,"  Relative standard deviation: %g %%\n",
-				  (double)100*bstdev/bmean);
-			  output_string(buffer);
-			}
-                        sprintf(buffer,"  Number of runs: %lu\n",bnumrun);
-                        output_string(buffer);
-                        show_stats(i);
-                        sprintf(buffer,"Done with %s\n\n",ftestnames[i]);
-                        output_string(buffer);
+                                if (bmean>(double)1e-100){
+                                /* avoid division by zero */
+                                sprintf(buffer,"  Relative standard deviation: %g %%\n",
+                                        (double)100*bstdev/bmean);
+                                output_string(buffer);
+                                }
+                                sprintf(buffer,"  Number of runs: %lu\n",bnumrun);
+                                output_string(buffer);
+                                show_stats(i);
+                                sprintf(buffer,"Done with %s\n\n",ftestnames[i]);
+                                output_string(buffer);
+                        }
                 }
-        }
-}//END FOR LOOP
+        }//END FOR LOOP
 
-output_string("=================================TEST COMPLETED=================================\n");
+        output_string("=================================TEST COMPLETED=======================================\n");
 
-/* printf("...done...\n"); */
+        /* printf("...done...\n"); */
 
-/*
-** Output the total indexes
-*/
-/*
-if(global_custrun==0)
-{
-        output_string("==========================ORIGINAL BYTEMARK RESULTS==========================\n");
-        sprintf(buffer,"INTEGER INDEX       : %.3f\n",
-                       pow(intindex,(double).142857));
-        output_string(buffer);
-        sprintf(buffer,"FLOATING-POINT INDEX: %.3f\n",
-                        pow(fpindex,(double).33333));
-        output_string(buffer);
-        output_string("Baseline (MSDOS*)   : Pentium* 90, 256 KB L2-cache, Watcom* compiler 10.0\n");
-#ifdef LINUX
-        output_string("==============================LINUX DATA BELOW===============================\n");
-	hardware(write_to_file, global_ofile);
-#include "sysinfoc.c"
-        sprintf(buffer,"MEMORY INDEX        : %.3f\n",
-                       pow(lx_memindex,(double).3333333333));
-        output_string(buffer);
-        sprintf(buffer,"INTEGER INDEX       : %.3f\n",
-                       pow(lx_intindex,(double).25));
-        output_string(buffer);
-        sprintf(buffer,"FLOATING-POINT INDEX: %.3f\n",
-                        pow(lx_fpindex,(double).3333333333));
-        output_string(buffer);
-        output_string("Baseline (LINUX)    : AMD K6/233*, 512 KB L2-cache, gcc 2.7.2.3, libc-5.4.38\n");
-#endif
-output_string("* Trademarks are property of their respective holder.\n");
-}
-*/
-exit(0);
+        /*
+        ** Output the total indexes
+        */
+        /*
+        if(global_custrun==0)
+        {
+                output_string("==========================ORIGINAL BYTEMARK RESULTS==========================\n");
+                sprintf(buffer,"INTEGER INDEX       : %.3f\n",
+                        pow(intindex,(double).142857));
+                output_string(buffer);
+                sprintf(buffer,"FLOATING-POINT INDEX: %.3f\n",
+                                pow(fpindex,(double).33333));
+                output_string(buffer);
+                output_string("Baseline (MSDOS*)   : Pentium* 90, 256 KB L2-cache, Watcom* compiler 10.0\n");
+        #ifdef LINUX
+                output_string("==============================LINUX DATA BELOW===============================\n");
+                hardware(write_to_file, global_ofile);
+        #include "sysinfoc.c"
+                sprintf(buffer,"MEMORY INDEX        : %.3f\n",
+                        pow(lx_memindex,(double).3333333333));
+                output_string(buffer);
+                sprintf(buffer,"INTEGER INDEX       : %.3f\n",
+                        pow(lx_intindex,(double).25));
+                output_string(buffer);
+                sprintf(buffer,"FLOATING-POINT INDEX: %.3f\n",
+                                pow(lx_fpindex,(double).3333333333));
+                output_string(buffer);
+                output_string("Baseline (LINUX)    : AMD K6/233*, 512 KB L2-cache, gcc 2.7.2.3, libc-5.4.38\n");
+        #endif
+        output_string("* Trademarks are property of their respective holder.\n");
+        }
+        */
+        exit(0);
 }
 //END OF MAIN
 
@@ -788,81 +792,95 @@
         double *stdev,                  /* Standard deviation */
         ulong *numtries)                /* # of attempts */
 {
-double myscores[30];            /* Need at least 5 scores, use at most 30 */
-double c_half_interval;         /* Confidence half interval */
-int i;                          /* Index */
-/* double newscore; */          /* For improving confidence interval */
+        #define N_RUNS 25
 
-/*
-** Get first 5 scores.  Then begin confidence testing.
-*/
-for (i=0;i<5;i++)
-{       (*funcpointer[fid])();
-        myscores[i]=getscore(fid);
-#ifdef DEBUG
-	printf("score # %d = %g\n", i, myscores[i]);
-#endif
-}
-*numtries=5;            /* Show 5 attempts */
+        double myscores[N_RUNS+1];            /* Need at least 5 scores, use at most 30 */
+        double c_half_interval;         /* Confidence half interval */
+        int i;                          /* Index */
+        /* double newscore; */          /* For improving confidence interval */
+
+
+        for (i=0;i<N_RUNS;++i) {
+                (*funcpointer[fid])();
+                myscores[i]=getscore(fid);
+                //printf("score: %f\n", myscores[i]);
+        }
+        *numtries = N_RUNS;
+
+        return calc_confidence(myscores, *numtries, &c_half_interval, mean, stdev);
 
-/*
-** The system allows a maximum of 30 tries before it gives
-** up.  Since we've done 5 already, we'll allow 25 more.
-*/
 
-/*
-** Enter loop to test for confidence criteria.
-*/
-while(1)
-{
         /*
-        ** Calculate confidence. Should always return 0.
+        ** Get first 5 scores.  Then begin confidence testing.
         */
-        if (0!=calc_confidence(myscores,
-		*numtries,
-                &c_half_interval,
-                mean,
-                stdev)) return(-1);
+        for (i=0;i<5;i++)
+        {       
+                (*funcpointer[fid])();
+                myscores[i]=getscore(fid);
+        #ifdef DEBUG
+                printf("score # %d = %g\n", i, myscores[i]);
+        #endif
+        }
+        *numtries=5;            /* Show 5 attempts */
 
         /*
-        ** Is the length of the half interval 5% or less of mean?
-        ** If so, we can go home.  Otherwise, we have to continue.
+        ** The system allows a maximum of 30 tries before it gives
+        ** up.  Since we've done 5 already, we'll allow 25 more.
         */
-       if(c_half_interval/ (*mean) <= (double)0.01)
-      //  if(c_half_interval/ (*mean) <= (double)0.05)
-                break;
 
-#ifdef OLDCODE
-#undef OLDCODE
-#endif
-#ifdef OLDCODE
-/* this code is no longer valid, we now do not replace but add new scores */
-/* Uwe F. Mayer */
-	      /*
-	      ** Go get a new score and see if it
-	      ** improves existing scores.
-	      */
-	      do {
-		      if(*numtries==10)
-			      return(-1);
-		      (*funcpointer[fid])();
-		      *numtries+=1;
-		      newscore=getscore(fid);
-	      } while(seek_confidence(myscores,&newscore,
-		      &c_half_interval,mean,stdev)==0);
-#endif
-	/* We now simply add a new test run and hope that the runs
-           finally stabilize, Uwe F. Mayer */
-	if(*numtries==30) return(-1);
-	(*funcpointer[fid])();
-	myscores[*numtries]=getscore(fid);
-#ifdef DEBUG
-	printf("score # %ld = %g\n", *numtries, myscores[*numtries]);
-#endif
-	*numtries+=1;
-}
+        /*
+        ** Enter loop to test for confidence criteria.
+        */
+        while(1)
+        {
+                /*
+                ** Calculate confidence. Should always return 0.
+                */
+                if (0!=calc_confidence(myscores,
+                        *numtries,
+                        &c_half_interval,
+                        mean,
+                        stdev)) return(-1);
 
-return(0);
+                /*
+                ** Is the length of the half interval 5% or less of mean?
+                ** If so, we can go home.  Otherwise, we have to continue.
+                */
+        if(c_half_interval/ (*mean) <= (double)0.01)
+        //  if(c_half_interval/ (*mean) <= (double)0.05)
+                        break;
+
+        #ifdef OLDCODE
+        #undef OLDCODE
+        #endif
+        #ifdef OLDCODE
+        /* this code is no longer valid, we now do not replace but add new scores */
+        /* Uwe F. Mayer */
+                /*
+                ** Go get a new score and see if it
+                ** improves existing scores.
+                */
+                do {
+                        if(*numtries==10)
+                                return(-1);
+                        (*funcpointer[fid])();
+                        *numtries+=1;
+                        newscore=getscore(fid);
+                } while(seek_confidence(myscores,&newscore,
+                        &c_half_interval,mean,stdev)==0);
+        #endif
+                /* We now simply add a new test run and hope that the runs
+                finally stabilize, Uwe F. Mayer */
+                if(*numtries==30) return(-1);
+                (*funcpointer[fid])();
+                myscores[*numtries]=getscore(fid);
+        #ifdef DEBUG
+                printf("score # %ld = %g\n", *numtries, myscores[*numtries]);
+        #endif
+                *numtries+=1;
+        }
+
+        return(0);
 }
 
 #ifdef OLDCODE
@@ -940,17 +958,18 @@
 /* Here is a list of the student-t distribution up to 29 degrees of
    freedom. The value at 0 is bogus, as there is no value for zero
    degrees of freedom. */
-double student_t[30]={0.0 , 12.706 , 4.303 , 3.182 , 2.776 , 2.571 ,
+/*double student_t[30]={0.0 , 12.706 , 4.303 , 3.182 , 2.776 , 2.571 ,
                              2.447 , 2.365 , 2.306 , 2.262 , 2.228 ,
                              2.201 , 2.179 , 2.160 , 2.145 , 2.131 ,
                              2.120 , 2.110 , 2.101 , 2.093 , 2.086 ,
                              2.080 , 2.074 , 2.069 , 2.064 , 2.060 ,
 		             2.056 , 2.052 , 2.048 , 2.045 };
+                             */
 int i;          /* Index */
-if ((num_scores<2) || (num_scores>30)) {
+/*if ((num_scores<2) || (num_scores>30)) {
   output_string("Internal error: calc_confidence called with an illegal number of scores\n");
   return(-1);
-}
+}*/
 /*
 ** First calculate mean.
 */
@@ -974,7 +993,7 @@
 ** with num_scores-1 degrees of freedom, and dividing by sqrt(number of
 ** observations). See any introduction to statistics.
 */
-*c_half_interval=student_t[num_scores-1] * (*sdev) / sqrt((double)num_scores);
+*c_half_interval=0.0;//student_t[num_scores-1] * (*sdev) / sqrt((double)num_scores);
 return(0);
 }
 
@@ -1028,8 +1047,10 @@
 {
 
 printf("%s",buffer);
+fflush(stdout);
 if(write_to_file!=0)
         fprintf(global_ofile,"%s",buffer);
+        fflush(global_ofile);
 return;
 }
 
diff --color -ur sgx-nbench/nbenchPortal/nbench0.h sgx-nbench1/nbenchPortal/nbench0.h
--- sgx-nbench/nbenchPortal/nbench0.h	2022-05-02 18:22:14.587889680 +0200
+++ sgx-nbench1/nbenchPortal/nbench0.h	2022-05-02 16:32:45.731526000 +0200
@@ -91,7 +91,7 @@
 #define TF_NNET 8
 #define TF_LU 9
 
-#define NUMTESTS 10
+#define NUMTESTS 9
 
 /*
 ** GLOBALS
@@ -106,7 +106,7 @@
         "NUMERIC SORT    ",
         "STRING SORT     ",
         "BITFIELD        ",
-        "FP EMULATION    ",
+        //"FP EMULATION    ",
         "FOURIER         ",
         "ASSIGNMENT      ",
         "IDEA            ",
@@ -114,6 +114,10 @@
         "NEURAL NET      ",
         "LU DECOMPOSITION" };
 
+
+
+
+
 /*
 ** Indexes -- Baseline is DELL Pentium XP90
 ** 11/28/94
@@ -122,7 +126,7 @@
     38.993,                     /* Numeric sort */
     2.238,                      /* String sort */
     5829704,                    /* Bitfield */
-    2.084,                      /* FP Emulation */
+    //2.084,                      /* FP Emulation */
     879.278,                    /* Fourier */
     .2628,                      /* Assignment */
     65.382,                     /* IDEA */
@@ -139,7 +143,7 @@
       118.73, 	    /* Numeric sort */
       14.459,	    /* String sort */
     27910000,	    /* Bitfield */
-      9.0314,	    /* FP Emulation */
+      //9.0314,	    /* FP Emulation */
       1565.5,	    /* Fourier */
       1.0132,	    /* Assignment */
       220.21,	    /* IDEA */
@@ -247,7 +251,7 @@
 {       (void *)&global_numsortstruct,
         (void *)&global_strsortstruct,
         (void *)&global_bitopstruct,
-        (void *)&global_emfloatstruct,
+        //(void *)&global_emfloatstruct,
         (void *)&global_fourierstruct,
         (void *)&global_assignstruct,
         (void *)&global_ideastruct,
@@ -338,6 +342,8 @@
 
 extern void ErrorExit(void);    /* From SYSSPEC */
 
+
+
 /*
 ** Array of pointers to the benchmark functions.
 */
@@ -345,12 +351,10 @@
 {       DoNumSort,
         DoStringSort,
         DoBitops,
-        DoEmFloat,
+        //DoEmFloat,
         DoFourier,
         DoAssign,
         DoIDEA,
         DoHuffman,
         DoNNET,
-        DoLU };
-
-
+        DoLU };
\ No newline at end of file
diff --color -ur sgx-nbench/nbenchPortal/nbench1.c sgx-nbench1/nbenchPortal/nbench1.c
--- sgx-nbench/nbenchPortal/nbench1.c	2022-05-02 18:22:14.587889680 +0200
+++ sgx-nbench1/nbenchPortal/nbench1.c	2022-05-02 16:32:45.731526000 +0200
@@ -974,7 +974,7 @@
 		if(DoAssignIteration(arraybase,
 			locassignstruct->numarrays)>global_min_ticks)
 			break;          /* We're ok...exit */
-				printf("after\n");
+				//printf("after\n");
 		app_FreeMemory();
 		locassignstruct->numarrays++;
 	}
diff --color -ur sgx-nbench/nbenchPortal/nmglobal.h sgx-nbench1/nbenchPortal/nmglobal.h
--- sgx-nbench/nbenchPortal/nmglobal.h	2022-05-02 18:22:14.591889726 +0200
+++ sgx-nbench1/nbenchPortal/nmglobal.h	2022-05-02 16:32:45.731526000 +0200
@@ -142,14 +142,14 @@
 /*
 ** ERROR CODES
 */
-#define ERROR_MEMORY    1
-#define ERROR_MEMARRAY_FULL 2
+#define ERROR_MEMORY          1
+#define ERROR_MEMARRAY_FULL   2
 #define ERROR_MEMARRAY_NFOUND 3
-#define ERROR_FILECREATE 10
-#define ERROR_FILEREAD 11
-#define ERROR_FILEWRITE 12
-#define ERROR_FILEOPEN 13
-#define ERROR_FILESEEK 14
+#define ERROR_FILECREATE      10
+#define ERROR_FILEREAD        11
+#define ERROR_FILEWRITE       12
+#define ERROR_FILEOPEN        13
+#define ERROR_FILESEEK        14
 
 /*
 ** MINIMUM_TICKS
@@ -187,8 +187,8 @@
 ** OTHER DEFINES
 */
 #ifndef MAC
-#define TRUE    1
-#define FALSE   0
+#define TRUE  1
+#define FALSE 0
 #endif
 
 /*
@@ -200,9 +200,9 @@
 /*
 ** TYPEDEFS
 */
-#define ulong unsigned long
-#define uchar unsigned char
-#define uint unsigned int
+#define ulong  unsigned long
+#define uchar  unsigned char
+#define uint   unsigned int
 #define ushort unsigned short
 /*
 typedef unsigned char uchar;
@@ -217,20 +217,20 @@
 ** map 'farxxx' to 'xxx'
 */
 #ifdef DOS16
-typedef void huge farvoid;
-typedef double huge fardouble;
-typedef long huge farlong;
+typedef void huge          farvoid;
+typedef double huge        fardouble;
+typedef long huge          farlong;
 typedef unsigned long huge farulong;
-typedef char huge farchar;
+typedef char huge          farchar;
 typedef unsigned char huge faruchar;
 
 #else
 
-typedef void farvoid;
-typedef double fardouble;
-typedef long farlong;
+typedef void          farvoid;
+typedef double        fardouble;
+typedef long          farlong;
 typedef unsigned long farulong;
-typedef char farchar;
+typedef char          farchar;
 typedef unsigned char faruchar;
 
 #endif
@@ -240,14 +240,25 @@
 ** is critical.  You'll have to alter these for
 ** your specifical platform/compiler.
 */
-typedef unsigned char u8;       /* Unsigned 8-bits */
-typedef unsigned short u16;     /* Unsigned 16 bits */
+#ifndef u8
+typedef unsigned char u8; /* Unsigned 8-bits */
+#endif
+
+#ifndef u16
+typedef unsigned char u16; /* Unsigned 8-bits */
+#endif
+
 #ifdef LONG64
-typedef unsigned int u32;       /* Unsigned 32 bits */
-typedef int int32;              /* Signed 32 bit integer */
+#ifndef u32
+typedef unsigned char u32; /* Unsigned 8-bits */
+#endif
+#ifndef int32
+typedef unsigned char int32; /* Unsigned 8-bits */
+#endif
+
 #else
-typedef unsigned long u32;      /* Unsigned 32 bits */
-typedef long int32;              /* Signed 32 bit integer */
+typedef unsigned long u32;   /* Unsigned 32 bits */
+typedef long          int32; /* Signed 32 bit integer */
 #endif
 
 /*****************
@@ -265,7 +276,7 @@
 ** amount of memory in the system.
 */
 /*#define NUMNUMARRAYS    1000*/
-#define NUMNUMARRAYS    10000
+#define NUMNUMARRAYS 10000
 
 /*
 ** The following constant NUMARRAYSIZE determines the
@@ -273,18 +284,17 @@
 ** this is something you shouldn't fool with, though as
 ** with most of the constants here, it is adjustable.
 */
-#define NUMARRAYSIZE    8111L
-
+#define NUMARRAYSIZE 8111L
 
 /*
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* # of seconds requested */
-        double sortspersec;     /* # of sort iterations per sec */
-        ushort numarrays;       /* # of arrays */
-        ulong arraysize;        /* # of elements in array */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* # of seconds requested */
+    double sortspersec;  /* # of sort iterations per sec */
+    ushort numarrays;    /* # of arrays */
+    ulong  arraysize;    /* # of elements in array */
 } SortStruct;
 
 /****************
@@ -328,11 +338,11 @@
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* # of seconds requested */
-        double bitopspersec;    /* # of bitfield ops per sec */
-        ulong bitoparraysize;           /* Total # of bitfield ops */
-        ulong bitfieldarraysize;        /* Bit field array size */
+    int    adjust;            /* Set adjust code */
+    ulong  request_secs;      /* # of seconds requested */
+    double bitopspersec;      /* # of bitfield ops per sec */
+    ulong  bitoparraysize;    /* Total # of bitfield ops */
+    ulong  bitfieldarraysize; /* Bit field array size */
 } BitOpStruct;
 
 /****************************
@@ -362,11 +372,11 @@
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* # of seconds requested */
-        ulong arraysize;        /* Size of array */
-        ulong loops;            /* Loops per iterations */
-        double emflops;         /* Results */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* # of seconds requested */
+    ulong  arraysize;    /* Size of array */
+    ulong  loops;        /* Loops per iterations */
+    double emflops;      /* Results */
 } EmFloatStruct;
 
 /*************************
@@ -377,10 +387,10 @@
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* # of requested seconds */
-        ulong arraysize;        /* Size of coeff. arrays */
-        double fflops;          /* Results */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* # of requested seconds */
+    ulong  arraysize;    /* Size of coeff. arrays */
+    double fflops;       /* Results */
 } FourierStruct;
 
 /*************************
@@ -391,10 +401,10 @@
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* Requested # of seconds */
-        ulong numarrays;        /* # of arrays */
-        double iterspersec;     /* Results */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* Requested # of seconds */
+    ulong  numarrays;    /* # of arrays */
+    double iterspersec;  /* Results */
 } AssignStruct;
 
 /********************
@@ -421,14 +431,13 @@
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* Requested # of seconds */
-        ulong arraysize;        /* Size of array */
-        ulong loops;            /* # of times to convert */
-        double iterspersec;     /* Results */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* Requested # of seconds */
+    ulong  arraysize;    /* Size of array */
+    ulong  loops;        /* # of times to convert */
+    double iterspersec;  /* Results */
 } IDEAStruct;
 
-
 /************************
 ** HUFFMAN COMPRESSION **
 ************************/
@@ -459,11 +468,11 @@
 */
 
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* Requested # of seconds */
-        ulong arraysize;        /* Size of array */
-        ulong loops;            /* # of times to compress/decompress */
-        double iterspersec;     /* Results */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* Requested # of seconds */
+    ulong  arraysize;    /* Size of array */
+    ulong  loops;        /* # of times to compress/decompress */
+    double iterspersec;  /* Results */
 } HuffStruct;
 
 /********************************
@@ -479,16 +488,16 @@
 ** has sufficient horsepower.
 */
 /*#define MAXNNETLOOPS  50000L*/
-#define MAXNNETLOOPS  500000L
+#define MAXNNETLOOPS 500000L
 
 /*
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* Requested # of seconds */
-        ulong loops;            /* # of times to learn */
-        double iterspersec;     /* Results */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* Requested # of seconds */
+    ulong  loops;        /* # of times to learn */
+    double iterspersec;  /* Results */
 } NNetStruct;
 
 /***********************
@@ -511,9 +520,8 @@
 ** TYPEDEFS
 */
 typedef struct {
-        int adjust;             /* Set adjust code */
-        ulong request_secs;     /* Requested # of seconds */
-        ulong numarrays;        /* # of arrays */
-        double iterspersec;     /* Results */
+    int    adjust;       /* Set adjust code */
+    ulong  request_secs; /* Requested # of seconds */
+    ulong  numarrays;    /* # of arrays */
+    double iterspersec;  /* Results */
 } LUStruct;
-
Only in sgx-nbench1/nbenchPortal: pointer
Only in sgx-nbench1/nbenchPortal: pointer.h
Only in sgx-nbench1/nbenchPortal: sysinfo.c
Only in sgx-nbench1/nbenchPortal: sysinfoc.c
